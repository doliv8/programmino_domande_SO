[
  {
    "domanda": "Nel processo di compilazione di un file sorgente in ambiente Linux, il passo che coinvolge \"l'assembler\" ha lo scopo di:",
    "opzioni": [
      "Convertire il codice dal linguaggio sorgente al linguaggio assembly",
      "Convertire il file eseguibile precedentemente generato in linguaggio macchina",
      "Convertire il codice dal linguaggio assembly al linguaggio macchina"
    ],
    "soluzioni": [
      "Convertire il codice dal linguaggio assembly al linguaggio macchina"
    ]
  },
  {
    "domanda": "Selezionare le affermazioni corrette riguardo alla definizione di \"comando\":",
    "opzioni": [
      "I soli programmi contenuti all'interno della directory \"/bin\"",
      "Un comando è composto dal nome del comando stesso, da una o più opzioni facoltative e da uno o più argomenti facoltativi",
      "Un comando è composto dal nome del comando stesso e da almeno una opzione"
    ],
    "soluzioni": [
      "Un comando è composto dal nome del comando stesso, da una o più opzioni facoltative e da uno o più argomenti facoltativi"
    ]
  },
  {
    "domanda": "Selezionare i metodi corretti per effettuare operazioni matematiche nel linguaggio bash:",
    "opzioni": [
      "a= expr 5+3'",
      "let a=2+3",
      "((a=4+1))"
    ],
    "soluzioni": [
      "let a=2+3",
      "((a=4+1))"
    ]
  },
  {
    "domanda": "Il comando \"cmp\", in caso di file differenti:",
    "opzioni": [
      "Visualizza sullo standard output il numero di differenze esistenti tra i file considerati",
      "Visualizza sullo standard output la differenza riscontrata a partire da dove essa è stata individuata",
      "Visualizza sullo standard output un elenco delle differenze riscontrate sui file"
    ],
    "soluzioni": [
      "Visualizza sullo standard output la differenza riscontrata a partire da dove essa è stata individuata"
    ]
  },
  {
    "domanda": "Dire se la seguente affermazione è corretta: \"Se il mutex è già in stato di lock da parte di un altro thread, la funzione pthread_mutex_lock blocca la propria esecuzione e ritorna al thread chiamante solo quando il mutex viene rilasciato (unlock) dal thread che ne ha eseguito il lock\"",
    "opzioni": [
      "Solo l'ultima parte è corretta",
      "No, non è corretta",
      "Sì, è corretta"
    ],
    "soluzioni": [
      "Sì, è corretta"
    ]
  },
  {
    "domanda": "Secondo il metodo assoluto, possiamo specificare tutti i permessi di tutte le categorie di utenti contemporaneamente usando le:",
    "opzioni": [
      "Maschere binarie",
      "Maschere simboliche",
      "Maschere ottali"
    ],
    "soluzioni": [
      "Maschere binarie"
    ]
  },
  {
    "domanda": "Valutare la correttezza dell'affermazione \"la programmazione di sistema consiste nell'utilizzare l'interfaccia di system call fra il kernel e le applicazioni che girano sotto Linux\"",
    "opzioni": [
      "L'affermazione non è corretta",
      "L'affermazione è corretta",
      "L'affermazione è corretta parzialmente"
    ],
    "soluzioni": [
      "L'affermazione è corretta"
    ]
  },
  {
    "domanda": "Il comando \"chgrp\" viene utilizzato per:",
    "opzioni": [
      "Cambiare il gruppo ad un file ed accetta due argomenti",
      "Cambiare il gruppo ad un file ed accetta un solo argomento",
      "Non esiste questo comando Bash"
    ],
    "soluzioni": [
      "Cambiare il gruppo ad un file ed accetta due argomenti"
    ]
  },
  {
    "domanda": "Selezionare le affermazioni corrette:",
    "opzioni": [
      "\"cat\" visualizza il contenuto di un file di testo",
      "\"less\" visualizza il file di testo, pagina per pagina",
      "\"more\" funziona come \"less\", ma ha meno funzioni"
    ],
    "soluzioni": [
      "\"cat\" visualizza il contenuto di un file di testo",
      "\"less\" visualizza il file di testo, pagina per pagina",
      "\"more\" funziona come \"less\", ma ha meno funzioni"
    ],
    "nota": "Il documento segna tutte e tre le opzioni come corrette."
  },
  {
    "domanda": "Le funzioni di gestione dei thread fanno parte della libreria standard del C dei sistemi Linux",
    "opzioni": [
      "Falso",
      "Vero",
      "Alcune"
    ],
    "soluzioni": [
      "Falso"
    ]
  },
  {
    "domanda": "Il percorso \"../../../cucina/ricette/secondi\" è stato formulato in modo:",
    "opzioni": [
      "Assoluto",
      "Relativo",
      "Non è un percorso correttamente formulato"
    ],
    "soluzioni": [
      "Relativo"
    ]
  },
  {
    "domanda": "Dire se questa sequenza di istruzioni per l'inizializzazione di un mutex è corretta: pthread_mutex(&mutex, NULL); pthread_mutex_t mutex;",
    "opzioni": [
      "No, non è corretta",
      "Sì, è corretta",
      "Le istruzioni sono invertite"
    ],
    "soluzioni": [
      "No, non è corretta"
    ]
  },
  {
    "domanda": "Dire quale compito svolge il seguente comando: test -x /bin/ls",
    "opzioni": [
      "Verificare se \"ls\" è un file eseguibile",
      "Non esiste l'opzione \"-x\"",
      "Verificare se \"ls\" è un file con dimensione zero"
    ],
    "soluzioni": [
      "Verificare se \"ls\" è un file eseguibile"
    ]
  },
  {
    "domanda": "Il comando \"ln file1 data1\" crea un link di tipo:",
    "opzioni": [
      "Fisico",
      "Esclusivo",
      "Simbolico"
    ],
    "soluzioni": [
      "Fisico"
    ]
  },
  {
    "domanda": "Tipicamente, tutte le funzioni di ncurses restituiscono:",
    "opzioni": [
      "Solo valori positivi",
      "Solo valori negativi",
      "Valori positivi o negativi"
    ],
    "soluzioni": [
      "Valori positivi o negativi"
    ]
  },
  {
    "domanda": "Dire se il seguente schema descrittivo del funzionamento delle \"pipe\" è corretto (\"fd\"=file descriptor): [Schema Immagine]",
    "opzioni": [
      "Si, lo schema è corretto",
      "Si, lo schema è corretto ma incompleto",
      "No, lo schema non è corretto"
    ],
    "soluzioni": [
      "No, lo schema non è corretto"
    ]
  },
  {
    "domanda": "Se utilizziamo il comando fg per portare in foreground un job che prima era in background, senza specificare il job su cui agire:",
    "opzioni": [
      "Dobbiamo necessariamente specificare il job su cui agire",
      "Tutti i jobs in background vengono portati in foreground",
      "Implicitamente ci riferiamo a quello attuale."
    ],
    "soluzioni": [
      "Implicitamente ci riferiamo a quello attuale."
    ]
  },
  {
    "domanda": "Il linguaggio C consente di definire strutture dati complesse",
    "opzioni": [
      "Dipende dal numero di classi",
      "Vero",
      "Falso"
    ],
    "soluzioni": [
      "Vero"
    ]
  },
  {
    "domanda": "Un \"semaforo binario\":",
    "opzioni": [
      "E' una variabile ti tipo binario che prende il nome di mutex",
      "E' un intero che può assumere soltanto valori booleani (zero o uno) e che prende il nome di mutex",
      "E' un intero che assumere valori sotto il controllo di un mutex binario"
    ],
    "soluzioni": [
      "E' un intero che può assumere soltanto valori booleani (zero o uno) e che prende il nome di mutex"
    ]
  },
  {
    "domanda": "Selezionare la corretta definizione formale di una directory (cartella):",
    "opzioni": [
      "Una directory è un tipo particolare di file associato a degli inode",
      "Una directory è una cartella che contiene una lista di file",
      "Una directory è un file che contiene una lista di nomi associati a degli inode"
    ],
    "soluzioni": [
      "Una directory è una cartella che contiene una lista di file"
    ]
  },
  {
    "domanda": "Il comando \"pwd\":",
    "opzioni": [
      "Visualizza il contenuto di un file di testo",
      "Acronimo di Paint White Directory, serve a cancellare il contenuto della shell corrente",
      "Visualizza il percorso corrente"
    ],
    "soluzioni": [
      "Visualizza il percorso corrente"
    ]
  },
  {
    "domanda": "Dire se la seguente affermazione è corretta: \"Per creare un mutex è necessario creare una variabile di tipo pthread_mutex_init e passare un puntatore a questa variabile alla funzione pthread_mutex_t\"",
    "opzioni": [
      "Sì, è corretta",
      "Solo l'ultima parte è corretta",
      "No, non è corretta"
    ],
    "soluzioni": [
      "No, non è corretta"
    ]
  },
  {
    "domanda": "Considerando che un comando immesso mediante lo standard input può generare un messaggio di errore:",
    "opzioni": [
      "I messaggi di errore possono esclusivamente essere veicolati tramite lo standard output",
      "Il verificarsi di un errore inibisce il meccanismo dei canali di input/output",
      "Esiste un ulteriore canale denominato standard error"
    ],
    "soluzioni": [
      "Esiste un ulteriore canale denominato standard error"
    ]
  },
  {
    "domanda": "La lettura del contenuto di una variabile si ottiene facendone precedere il nome dal simbolo:",
    "opzioni": [
      "&",
      "#",
      "$"
    ],
    "soluzioni": [
      "$"
    ]
  },
  {
    "domanda": "Il linguaggio C dispone di elementi come classi e oggetti, mediante i quali consente una stesura strutturata e funzionale del codice",
    "opzioni": [
      "Vero",
      "Dispone solo di classi ma non di oggetti",
      "Falso"
    ],
    "soluzioni": [
      "Falso"
    ]
  },
  {
    "domanda": "Quando con \"chmod\" non specifichiamo una categoria di utenti (u, g, oppure o):",
    "opzioni": [
      "Il comando modifica i permessi relativi al solo utente proprietario",
      "Il comando genera un errore",
      "Il comando modifica i permessi per tutte le categorie"
    ],
    "soluzioni": [
      "Il comando modifica i permessi per tutte le categorie"
    ]
  },
  {
    "domanda": "Nell'ambito dell'associazione dei thread a livello kernel, selezionare i modelli di multithreading possibili:",
    "opzioni": [
      "One-to-Many",
      "One-to-One",
      "Many-to-One"
    ],
    "soluzioni": [
      "One-to-One",
      "Many-to-One"
    ]
  },

  {
    "domanda": "Dire se le seguenti system call sono equivalenti: 1) wait (&status) 2) waitpid(0, &status, 0)",
    "opzioni": [
      "La sintassi di waitpid è scorretta e genera un errore",
      "Si",
      "No"
    ],
    "soluzioni": [
      "No"
    ]
  },
  {
    "domanda": "La funzione initscr() di ncurses:",
    "opzioni": [
      "Inizializzare la libreria per l'impiego e cancellare lo schermo",
      "Cancellare e ridimensionare lo schermo",
      "Cancellare soltanto lo schermo"
    ],
    "soluzioni": [
      "Inizializzare la libreria per l'impiego e cancellare lo schermo"
    ]
  },
  {
    "domanda": "Per visualizzare il numero di righe vuote nel file \"miofile.txt\" tramite il comando grep, dobbiamo eseguire:",
    "opzioni": [
      "grep -c '$$' miofile.txt",
      "grep -c '^$' miofile.txt",
      "grep '^$' miofile.txt"
    ],
    "soluzioni": [
      "grep -c '^$' miofile.txt"
    ]
  },
  {
    "domanda": "L'affermazione \"ogni comando restituisce un exit status. Il successo restituisce 1, il fallimento un codice d'errore\" è corretta?",
    "opzioni": [
      "No, il successo restituisce 0",
      "Sì, è corretta",
      "No, il successo non restituisce nessun valore"
    ],
    "soluzioni": [
      "No, il successo restituisce 0"
    ]
  },
  {
    "domanda": "Trascinare la corretta istruzione all'interno nel seguente codice (execl):",
    "opzioni": [
      "execl(\"ls\", \"-1\", (char *)0);",
      "execl(\"/bin/ls\", \"-I\", (char *)0);",
      "execl(\"/bin/ls\", \"-I\", (char *)NULL);",
      "execl(\"/bin/\", \"ls -l\", (char)0);"
    ],
    "soluzioni": [
      "execl(\"/bin/ls\", \"-I\", (char *)0);"
    ]
  },
  {
    "domanda": "Il comando 'OBJECTS = file1.o file2.o' eseguito in shell:",
    "opzioni": [
      "Sovrascrive il valore precedentemente definito nel Makefile",
      "Genera un errore",
      "Non sovrascrive il valore precedentemente definito nel Makefile, in quanto prioritario"
    ],
    "soluzioni": [
      "Genera un errore"
    ]
  },
  {
    "domanda": "Nel seguente output, ottenuto tramite il comando \"ls -l\", cosa identifica la stringa \"due\"? (- rwx rwx rwx 1 uno due 210 Feb 18 12:10 tre)",
    "opzioni": [
      "Il proprietario del file",
      "Il gruppo di apparteneneza del proprietario del file",
      "Il nome del file"
    ],
    "soluzioni": [
      "Il gruppo di apparteneneza del proprietario del file"
    ]
  },
  {
    "domanda": "L'operazione di wait su un semaforo:",
    "opzioni": [
      "La wait opera solo nell'ambito dei mutex",
      "Decrementa il valore del semaforo di 1",
      "Incrementa il valore del semaforo di 1"
    ],
    "soluzioni": [
      "Decrementa il valore del semaforo di 1"
    ]
  },
  {
    "domanda": "In ambito bash, per dichiarare un array \"mydata\" di dimensione N devo scrivere:",
    "opzioni": [
      "{mydata[N]}",
      "mydata[N]",
      "{mydata}[N]"
    ],
    "soluzioni": [
      "mydata[N]"
    ]
  },
  {
    "domanda": "Una chiamata a \"pthread_create\" effettua immediatamente una return",
    "opzioni": [
      "Dipende dal contesto",
      "Vero",
      "Falso"
    ],
    "soluzioni": [
      "Vero"
    ]
  },
  {
    "domanda": "Il comando \"man\":",
    "opzioni": [
      "Visualizza le pagine di manuale del comando specificato come parametro",
      "Visualizza la breve descrizione di un comando",
      "Visualizza la tipologia del file specificato come argomento"
    ],
    "soluzioni": [
      "Visualizza le pagine di manuale del comando specificato come parametro"
    ]
  },
  {
    "domanda": "Selezionare una corretta definizione di shell Linux:",
    "opzioni": [
      "Una shell consente di immettere dei comandi in una finestra, emulando il funzionamento del kernel di un sistema di elaborazione Linux",
      "Una shell consente di immettere dei comandi in una finestra, emulando il funzionamento del terminale fisico di un sistema di elaborazione",
      "Una shell consente di interfacciarsi con il kernel Linux, senza l'impiego di librerie specifiche"
    ],
    "soluzioni": [
      "Una shell consente di immettere dei comandi in una finestra, emulando il funzionamento del terminale fisico di un sistema di elaborazione"
    ]
  },
  {
    "domanda": "La variabile speciale $@ :",
    "opzioni": [
      "Rappresenta in un'unica parola tutti i parametri posizionali passati allo script",
      "Rappresenta tutti i parametri posizionali passati allo script, ciascuno sotto forma di singola parola",
      "Restituisce il numero dei parametri"
    ],
    "soluzioni": [
      "Rappresenta tutti i parametri posizionali passati allo script, ciascuno sotto forma di singola parola"
    ]
  },
  {
    "domanda": "Nell'output del comando \"ls -l\", il primo carattere:",
    "opzioni": [
      "Indica il tipo di file",
      "Fornisce informazioni relative al proprietario del file o della cartella",
      "Indica il permesso di lettura del proprietario del file"
    ],
    "soluzioni": [
      "Indica il tipo di file"
    ]
  },
  {
    "domanda": "La funzione mvprintw() consente di specificare le coordinate di visualizzazione:",
    "opzioni": [
      "No",
      "Si possono specificare ma anche omettere",
      "Si"
    ],
    "soluzioni": [
      "Si"
    ]
  },
  {
    "domanda": "Dire se il seguente schema descrittivo del funzionamento delle \"pipe\" è corretto:",
    "opzioni": [
      "Si, lo schema è corretto",
      "No, gli indici degli array dei file descriptor sono errati",
      "No, la direzione delle frecce è invertita"
    ],
    "soluzioni": [
      "Si, lo schema è corretto"
    ]
  },
  {
    "domanda": "Il thread principale può creare nuovi thread, i quali eseguono lo stesso programma in:",
    "opzioni": [
      "Modo concorrente all'interno dello stesso thread",
      "Modo sincrono all'interno dello stesso processo",
      "Modo concorrente all'interno dello stesso processo"
    ],
    "soluzioni": [
      "Modo concorrente all'interno dello stesso processo"
    ]
  },
  {
    "domanda": "Il contatore di un semaforo può assumere valori negativi:",
    "opzioni": [
      "Falso",
      "Vero, in caso di errore",
      "Può assumere solo valori booleani, quindi 1 o 0"
    ],
    "soluzioni": [
      "Falso"
    ]
  },
  {
    "domanda": "Un thread viene identificato all'interno di un processo tramite:",
    "opzioni": [
      "Il suo file descriptor",
      "Un thread ID",
      "Un process ID (PID)"
    ],
    "soluzioni": [
      "Un thread ID"
    ]
  },
  {
    "domanda": "Selezionare il corretto prototipo della system call \"pipe\":",
    "opzioni": [
      "int pipe(int filedes[2])",
      "void pipe(int filedes[2])",
      "int pipe(char filedes[2])"
    ],
    "soluzioni": [
      "int pipe(int filedes[2])"
    ]
  },
  {
    "domanda": "Le variabili mutex devono essere inizializzate:",
    "opzioni": [
      "Una sola volta",
      "Sono già implicitamente inizializzate",
      "Ogni volta che si utilizzano"
    ],
    "soluzioni": [
      "Una sola volta"
    ]
  },
  {
    "domanda": "Nell'ambito dell'associazione dei thread a livello kernel, selezionare i modelli di multithreading possibili:",
    "opzioni": [
      "One-to-One",
      "One-to-Many",
      "Many-to-Many"
    ],
    "soluzioni": [
      "One-to-One",
      "Many-to-Many"
    ]
  },
  {
    "domanda": "Il principale limite delle pipe consiste nella:",
    "opzioni": [
      "Incapacità di comunicare con processi \"non imparentati\" tra loro",
      "Incapacità di comunicare con più di due processi",
      "Incapacità di comunicare con processi \"imparentati\" tra loro"
    ],
    "soluzioni": [
      "Incapacità di comunicare con processi \"non imparentati\" tra loro"
    ]
  },
  {
    "domanda": "I thread a livello utente sono gestiti da:",
    "opzioni": [
      "Direttamente dal kernel",
      "Una libreria",
      "Da una serie di interrupts hardware"
    ],
    "soluzioni": [
      "Una libreria"
    ]
  },
  {
    "domanda": "La variabile speciale $# :",
    "opzioni": [
      "Rappresenta tutti i parametri posizionali passati allo script, ciascuno sotto forma di singola parola",
      "Restituisce il numero dei parametri",
      "Rappresenta in un'unica parola tutti i parametri posizionali passati allo script"
    ],
    "soluzioni": [
      "Restituisce il numero dei parametri"
    ]
  },
  {
    "domanda": "La funzione napms():",
    "opzioni": [
      "Consente di creare un bordo predefinito nella window specificata",
      "Consente di inibire l'esecuzione del programma per un numero specificato di millisecondi",
      "Consente di non attendere l'input di getch()"
    ],
    "soluzioni": [
      "Consente di inibire l'esecuzione del programma per un numero specificato di millisecondi"
    ]
  },
  {
    "domanda": "La system call \"execl\" può essere adoperata in combinazione con una \"fork\":",
    "opzioni": [
      "Corretto",
      "Non è possibile usare insieme queste due system call",
      "Incorretto"
    ],
    "soluzioni": [
      "Corretto"
    ]
  },
  {
    "domanda": "Il comando \"ls\":",
    "opzioni": [
      "Sposta il contenuto di una directory",
      "Visualizza il contenuto di una directory",
      "Lista il contenuto dei file presenti all'interno di una directory"
    ],
    "soluzioni": [
      "Visualizza il contenuto di una directory"
    ]
  },
  {
    "domanda": "Valutare la correttezza dell'affermazione \"la system call wait() consente ad un processo di terminare uno dei suoi processi figli, ottenendo il valore ritornato dalla sua funzione exit()\"",
    "opzioni": [
      "L'affermazione è corretta se esiste un solo processo figlio",
      "L'affermazione è corretta",
      "L'affermazione non è corretta"
    ],
    "soluzioni": [
      "L'affermazione non è corretta"
    ]
  },

  {
    "domanda": "Il comando \"chmod g+w-x script.sh\":",
    "opzioni": [
      "Abilita il gruppo di utenti del quale fa parte il proprietario del file \"script.sh\" per la scrittura e disabilita i permessi di esecuzione del file",
      "Abilita il gruppo di utenti del quale fa parte il proprietario del file \"script.sh\" per l'esecuzione",
      "Genera un errore, in quanto la sintassi del comando chmod è errata"
    ],
    "soluzioni": [
      "Abilita il gruppo di utenti del quale fa parte il proprietario del file \"script.sh\" per la scrittura e disabilita i permessi di esecuzione del file"
    ]
  },
  {
    "domanda": "Se un file leggibile, scrivibile ed eseguibile viene posto all'interno di una directory che non è accessibile (perché ha il permesso di esecuzione disabilitato) il file stesso diventa:",
    "opzioni": [
      "Accessibile al solo proprietario",
      "Accessibile",
      "Inaccessibile"
    ],
    "soluzioni": [
      "Inaccessibile"
    ]
  },
  {
    "domanda": "Dire se il seguente frammento di codice è corretto: (for ((i=1; i <= $X; i++)) ...)",
    "opzioni": [
      "Si",
      "No",
      "Funziona togliendo le doppie virgolette nell'istruzione \"echo\""
    ],
    "soluzioni": [
      "No"
    ]
  },
  {
    "domanda": "Per conoscere l'elenco dei job esistenti ed il loro stato:",
    "opzioni": [
      "Il comando \"jobs\"",
      "Il comando \"listjobs\"",
      "Il comando \"stats\""
    ],
    "soluzioni": [
      "Il comando \"jobs\""
    ]
  },
  {
    "domanda": "Nell'ambito della shell (terminale) Linux, il tasto di tabulazione richiama la funzione di:",
    "opzioni": [
      "Autocompletamento",
      "Visualizzazione dei possibili comandi alternativi a quello digitato",
      "Scorrimento della cronologia (history) dei comandi utilizzati"
    ],
    "soluzioni": [
      "Autocompletamento"
    ]
  },
  {
    "domanda": "In ambito bash, per accedere al valore con indice n di un array denominato \"mydata\" devo scrivere:",
    "opzioni": [
      "${mydata[n]}",
      "$mydata[n]",
      "$[mydata(n)]"
    ],
    "soluzioni": [
      "${mydata[n]}"
    ]
  },
  {
    "domanda": "Per selezionare una coppia colore/sfondo precedentemente definita devo avvalermi della funzione:",
    "opzioni": [
      "COLOR_PAIR()",
      "attron()",
      "init_pair()"
    ],
    "soluzioni": [
      "attron()"
    ]
  },
  {
    "domanda": "L'invocazione della funzione keypad(a, b); ha l'effetto di:",
    "opzioni": [
      "Disattivare o attivare tramite il parametro \"a\" la gestione dei tasti funzione sulla window specificata nel parametro \"b\"",
      "Disattivare o attivare tramite il parametro \"b\" la gestione dei tasti funzione (keywords predefinite) sulla window specificata nel parametro \"a\"",
      "Genera un errore in quanto manca un parametro"
    ],
    "soluzioni": [
      "Disattivare o attivare tramite il parametro \"b\" la gestione dei tasti funzione (keywords predefinite) sulla window specificata nel parametro \"a\""
    ]
  },
  {
    "domanda": "In ncurses l'angolo in basso a sinistra ha coordinate:",
    "opzioni": [
      "(x=0,y=0)",
      "(x=COLS, y=LINES)",
      "(x=0, y=LINES)"
    ],
    "soluzioni": [
      "(x=0, y=LINES)"
    ]
  },
  {
    "domanda": "Quale tipo di commutazione tra threads supporta il sistema operativo Linux?",
    "opzioni": [
      "Kernel-level ma non quella user-level",
      "User-level e kernel-level",
      "User-level ma non quella kernel-level"
    ],
    "soluzioni": [
      "User-level e kernel-level"
    ]
  },
  {
    "domanda": "Se aggiungiamo al \"makefile\" un' altra regola che ha come \"target\" il precedente \"source\":",
    "opzioni": [
      "Makefile verifica prima le dipendenze ed esegue la regola \"target\" prima della regola \"source\"",
      "Makefile esegue la regola \"target\" prima della regola \"source\"",
      "Makefile verifica prima le dipendenze ed esegue la regola \"source\" prima della regola \"target\""
    ],
    "soluzioni": [
      "Makefile verifica prima le dipendenze ed esegue la regola \"source\" prima della regola \"target\""
    ]
  },
  {
    "domanda": "Per produrre l'eseguibile \"codice\" a partire dal file sorgente in linguaggio C \"codice.c\", in ambiente Linux, devo eseguire il seguente comando:",
    "opzioni": [
      "Entrambe le altre rispsoste sono corrette",
      "gcc codice.c",
      "gcc codice.c -o codice"
    ],
    "soluzioni": [
      "gcc codice.c -o codice"
    ]
  },
  {
    "domanda": "Il carattere speciale \".\" identifica:",
    "opzioni": [
      "La directory corrente",
      "Tutte le directory che si trovano al livello immediatamente superiore",
      "La directory che si trova al livello immediatamente superiore"
    ],
    "soluzioni": [
      "La directory corrente"
    ]
  },
  {
    "domanda": "In un linguaggio di programmazione di tipo compilato:",
    "opzioni": [
      "Non è sempre necessario convertire il codice sorgente in un formato eseguibile",
      "Il codice sorgente può essere immediatamente eseguito grazie all'impiego di librerie di sistema",
      "Il codice sorgente deve essere sempre convertito in un formato eseguibile"
    ],
    "soluzioni": [
      "Il codice sorgente deve essere sempre convertito in un formato eseguibile"
    ]
  },
  {
    "domanda": "Per ottenere il nome del terminale corrente (shell), possiamo utilizzare il comando:",
    "opzioni": [
      "tty",
      "terminal-name",
      "get"
    ],
    "soluzioni": [
      "tty"
    ]
  },
  {
    "domanda": "L'operatore di \"pipe\":",
    "opzioni": [
      "Consente di collegare l'output standard di un comando all'output standard di un secondo comando",
      "Consente di collegare l'input standard di un comando all'output standard di un secondo comando",
      "Consente di collegare l'output standard di un comando all'input standard di un secondo comando"
    ],
    "soluzioni": [
      "Consente di collegare l'output standard di un comando all'input standard di un secondo comando"
    ]
  },
  {
    "domanda": "Uno strumento che aiuta il programmatore nella fase di sviluppo, tenendo traccia delle modifiche apportate e delle dipendenze fra i vari file è:",
    "opzioni": [
      "il comando \"make\"",
      "Il debugger",
      "il comando \"makefile\""
    ],
    "soluzioni": [
      "il comando \"make\""
    ]
  },
  {
    "domanda": "Il comando \"grep '^2[234]' list.txt\"",
    "opzioni": [
      "Ricerca nel file specificato tutte le righe che iniziano con \"2\", \"3\" ο \"4\"",
      "Ricerca nel file specificato tutte le righe che iniziano con 22,23,24",
      "Ricerca nel file specificato tutte le righe che terminano con \"22\", \"23\" o \"24\""
    ],
    "soluzioni": [
      "Ricerca nel file specificato tutte le righe che iniziano con 22,23,24"
    ]
  },
  {
    "domanda": "Le variabili $1, $2,...sono:",
    "opzioni": [
      "Variabili argomentali associate all'esecuzione di uno script parametrizzato",
      "Variabili speciali associate ai vari argomenti passati durante l'esecuzione di uno script",
      "Variabili globali alle quali è possibile attribuire un valore durante l'esecuzione di uno script"
    ],
    "soluzioni": [
      "Variabili speciali associate ai vari argomenti passati durante l'esecuzione di uno script"
    ]
  },
  {
    "domanda": "Per eliminare una window precedentemente definita possiamo ricorrere alla funzione:",
    "opzioni": [
      "window(false)",
      "remove_window()",
      "delwin()"
    ],
    "soluzioni": [
      "delwin()"
    ]
  },
  {
    "domanda": "Il percorso \"/home/utente/documenti/lettere/mario\" è formulato in modo:",
    "opzioni": [
      "Assoluto",
      "Relativo",
      "Non è un percorso correttamente formulato"
    ],
    "soluzioni": [
      "Assoluto"
    ]
  },
  {
    "domanda": "I semafori si possono definire degli \"strumenti di sincronizzazione\"",
    "opzioni": [
      "Falso",
      "Vero",
      "Solo in ambito thread"
    ],
    "soluzioni": [
      "Vero"
    ]
  },
  {
    "domanda": "Il comando \"grep '^globe$' list.txt\"",
    "opzioni": [
      "Ricerca nel file specificato tutte le righe che non contengono la parola \"globe\"",
      "Ricerca nel file specificato tutte le righe che contengono solo la parola \"globe\"",
      "Ricerca nel file specificato tutte le righe che contengono la parola \"globe\""
    ],
    "soluzioni": [
      "Ricerca nel file specificato tutte le righe che contengono solo la parola \"globe\""
    ]
  },
  {
    "domanda": "Dire se la seguente affermazione è corretta: \"Se il mutex è già in stato di lock da parte di un altro thread, la funzione pthread_mutex_lock blocca la propria esecuzione e ritorna al thread chiamante solo quando il mutex viene rilasciato (unlock) dal thread che ne ha eseguito il lock\"",
    "opzioni": [
      "Sì, è corretta",
      "Solo l'ultima parte è corretta",
      "No, non è corretta"
    ],
    "soluzioni": [
      "Sì, è corretta"
    ]
  },

  {
    "domanda": "Per visualizzare le variabili definite si può usare il comando:",
    "opzioni": [
      "set",
      "echo",
      "env"
    ],
    "soluzioni": [
      "set"
    ]
  },
  {
    "domanda": "In ambito bash, è possibile inizializzare un array in questo modo: array = (1 2 3 4 5 6)",
    "opzioni": [
      "No",
      "Solo in questo caso (interi) ma non con altri tipi di dati (esempio, stringhe)",
      "Si"
    ],
    "soluzioni": [
      "Si"
    ]
  },
  {
    "domanda": "Il meccanismo di attivazione di un thread rappresenta:",
    "opzioni": [
      "Una operazione poco onerosa",
      "Non esiste un meccanismo di attivazione in ambito thread",
      "Una operazione molto onerosa"
    ],
    "soluzioni": [
      "Una operazione poco onerosa"
    ]
  },
  {
    "domanda": "Dire se le seguenti assegnazioni sono entrambe valide nel linguaggio bash: x=variabile y='pippo'",
    "opzioni": [
      "Sì, sono entrambi valide",
      "Sono entrambe errate",
      "No, la seconda non è valida"
    ],
    "soluzioni": [
      "Sì, sono entrambi valide"
    ]
  },
  {
    "domanda": "Thread e processi condividono le risorse in modo uguale:",
    "opzioni": [
      "Falso",
      "Non vi è condivisione di risorse",
      "Vero"
    ],
    "soluzioni": [
      "Falso"
    ]
  },
  {
    "domanda": "Il comando \"apropos\":",
    "opzioni": [
      "Visualizza i file presenti sulla cartella corrente, ordinandoli per funzione",
      "Visualizza parte dei file presenti sulla cartella corrente, sulla base di una stringa/sottostringa",
      "Effettua ricerche di stringhe/sottostringhe nelle pagine di manuale"
    ],
    "soluzioni": [
      "Effettua ricerche di stringhe/sottostringhe nelle pagine di manuale"
    ]
  },
  {
    "domanda": "Utilizzando il metodo assoluto per la modifica dei permessi, la maschera binaria 000 ha l'effetto di:",
    "opzioni": [
      "Lasciare inalterati i permessi",
      "Disabilitare tutti i permessi relativi al proprietario del file",
      "Disabilitare tutti i permessi a tutti gli utenti, proprietario compreso"
    ],
    "soluzioni": [
      "Disabilitare tutti i permessi a tutti gli utenti, proprietario compreso"
    ]
  },
  {
    "domanda": "La variabile speciale $*",
    "opzioni": [
      "Rappresenta tutti i parametri posizionali passati allo script, ciascuno sotto forma di singola parola",
      "Restituisce il numero dei parametri",
      "Rappresenta in un'unica parola tutti i parametri posizionali passati allo script"
    ],
    "soluzioni": [
      "Rappresenta in un'unica parola tutti i parametri posizionali passati allo script"
    ]
  },
  {
    "domanda": "Nell'ambito delle system call \"wait\" e \"waitpid\", con WEXITSTATUS(status):",
    "opzioni": [
      "Otteniamo un valore di tipo True se il processo termina normalmente",
      "Accediamo al valore restituito dalla \"exit\"",
      "Accediamo al valore restituito dalla \"wait\""
    ],
    "soluzioni": [
      "Accediamo al valore restituito dalla \"exit\""
    ]
  },
  {
    "domanda": "Le informazioni inserite mediante la tastiera vengono veicolate tramite un canale definito:",
    "opzioni": [
      "Standard keyboard",
      "Standard input",
      "Input channel"
    ],
    "soluzioni": [
      "Standard input"
    ]
  },
  {
    "domanda": "Utilizzando il metodo assoluto per la modifica dei permessi, la cifra ottale 5 corrisponde ad una maschera binaria ed ad un significato del tipo:",
    "opzioni": [
      "101, che codifica lettura abilitata, scrittura disabilitata ed esecuzione abilitata",
      "101, che codifica scrittura abilitata, lettura disabilitata ed esecuzione abilitata",
      "111, che codifica lettura abilitata, scrittura abilitata ed esecuzione abilitata"
    ],
    "soluzioni": [
      "101, che codifica lettura abilitata, scrittura disabilitata ed esecuzione abilitata"
    ]
  },
  {
    "domanda": "In riferimento al seguente codice (switch pid, execl...), dire quando verrà eseguita la riga \"printf(\"miariga\");\":",
    "opzioni": [
      "Al termine del processo padre",
      "Al termine del processo figlio",
      "Se non si verificano errori nella execl, mai"
    ],
    "soluzioni": [
      "Se non si verificano errori nella execl, mai"
    ]
  },
  {
    "domanda": "Per passare dei valori alle funzioni definite in linguaggio bash:",
    "opzioni": [
      "Si usa lo stesso meccanismo del passaggio dei parametri utilizzato dai comandi",
      "Non si possono passare valori alle funzioni bash",
      "Si usa il meccanismo delle variabili globali"
    ],
    "soluzioni": [
      "Si usa lo stesso meccanismo del passaggio dei parametri utilizzato dai comandi"
    ]
  },
  {
    "domanda": "Il processo di [1], preceduto dall'invocazione del [2], converte il codice [3] in linguaggio Assembly",
    "opzioni": [
      "Punto 1: compilazione",
      "Punto 2: preprocessore",
      "Punto 3: sorgente"
    ],
    "soluzioni": [
      "Punto 1: compilazione",
      "Punto 2: preprocessore",
      "Punto 3: sorgente"
    ]
  },
  {
    "domanda": "In ncurses l'angolo in basso a destra ha coordinate:",
    "opzioni": [
      "(x=COLS, y=0)",
      "(x=0, y=LINES)",
      "(x=COLS, y=LINES)"
    ],
    "soluzioni": [
      "(x=COLS, y=LINES)"
    ]
  },
  {
    "domanda": "Il comando \"ls -l\":",
    "opzioni": [
      "Lista i file regolari ma non le cartelle presenti nella directory corrente",
      "Elenca con numerosi dettagli i file della directory corrente",
      "Visualizze solo nomi e proprietari dei file e delle cartelle presenti della directory corrente"
    ],
    "soluzioni": [
      "Elenca con numerosi dettagli i file della directory corrente"
    ]
  },
  {
    "domanda": "Dire se il seguente frammento di codice è corretto: (for ((i=1; i <= $X; i++)) ...)",
    "opzioni": [
      "Si",
      "Funziona togliendo le doppie virgolette nell'istruzione \"echo\"",
      "No"
    ],
    "soluzioni": [
      "No"
    ]
  },
  {
    "domanda": "Per produrre un eseguibile da un programma C sono necessari:",
    "opzioni": [
      "4 passi, Compilatore, Assembler, Debugger e Linker",
      "3 passi, Compilatore, Assembler, Linker",
      "3 passi, Preprocessing, Compilatore, Linker"
    ],
    "soluzioni": [
      "3 passi, Preprocessing, Compilatore, Linker"
    ]
  },
  {
    "domanda": "Dire se questa sequenza di istruzioni per l'inizializzazione di un mutex è corretta: pthread_mutex_t mutex; pthread_mutex_init (&mutex, NULL);",
    "opzioni": [
      "Sì, è corretta",
      "No, non è corretta",
      "Le istruzioni sono invertite"
    ],
    "soluzioni": [
      "Sì, è corretta"
    ]
  },
  {
    "domanda": "La funzione mvprintw() consente di specificare:",
    "opzioni": [
      "Le coordinate dove scrivere",
      "Il colore e lo sfondo dei caratteri",
      "LA window dove scrivere"
    ],
    "soluzioni": [
      "Le coordinate dove scrivere"
    ]
  },
  {
    "domanda": "La funzione waitpid(PID) ci consente di:",
    "opzioni": [
      "Attendere la terminazione di qualunque figlio",
      "Attendere la terminazione dei figli con process group ID uguale a quello del processo corrente",
      "Attendere la terminazione dei figli con process group ID uguale al valore assoluto del PID specificato"
    ],
    "soluzioni": [
      "Attendere la terminazione dei figli con process group ID uguale al valore assoluto del PID specificato"
    ]
  },
  {
    "domanda": "Utilizzando i threads è possibile il verificarsi di una \"race condition\"",
    "opzioni": [
      "Dipende dal numero di threads, se sono meno di 3 non può verificarsi",
      "Si",
      "No, soltanto in ambito processi"
    ],
    "soluzioni": [
      "Si"
    ]
  },
  {
    "domanda": "In ncurses l'angolo in alto a destra ha coordinate:",
    "opzioni": [
      "(x=0, y=LINES)",
      "(x=0, y=0)",
      "(x=COLS, y=0)"
    ],
    "soluzioni": [
      "(x=COLS, y=0)"
    ]
  },
  {
    "domanda": "Come possiamo collegare l'output del comando, \"cat testo.txt\" al comando \"more\"?",
    "opzioni": [
      "cat testo.txt | more",
      "cat testo.txt > more",
      "Non è possibile effettuare questa operazione"
    ],
    "soluzioni": [
      "cat testo.txt | more"
    ]
  },
  {
    "domanda": "Il comando \"uniq\":",
    "opzioni": [
      "Confronta il contenuto di due file",
      "Rimuove le righe duplicate consecutive da un file che potrà essere utilizzata per un altro scopo",
      "Cerca file duplicati all'interno del percorso specificato"
    ],
    "soluzioni": [
      "Rimuove le righe duplicate consecutive da un file che potrà essere utilizzata per un altro scopo"
    ]
  },

  {
    "domanda": "Il comando \"ln nome_file altro_nome_file\":",
    "opzioni": [
      "Permette di creare ulteriori link al file, cioè creare un ulteriori nomi per referenziarlo",
      "Permette di creare ulteriori nomi per il file, cioè creare ulteriori link per referenziarlo",
      "Genera un errore"
    ],
    "soluzioni": [
      "Permette di creare ulteriori nomi per il file, cioè creare ulteriori link per referenziarlo"
    ]
  },
  {
    "domanda": "Alla funzione \"sem_init\" vanno passati:",
    "opzioni": [
      "Nessun parametro",
      "3 parametri",
      "2 parametri"
    ],
    "soluzioni": [
      "3 parametri"
    ]
  },
  {
    "domanda": "Nei sistemi operativi Linux, un \"file descriptor\" è:",
    "opzioni": [
      "Un numero intero negativo solo in caso di errore",
      "Un numero con il quale possiamo riferirci allo standard \"input\", \"output\" ed \"error\"",
      "Un numero intero non negativo"
    ],
    "soluzioni": [
      "Un numero intero non negativo"
    ]
  },
  {
    "domanda": "Selezionare le affermazioni corrette su \"file descriptor\" e \"pipe\":",
    "opzioni": [
      "Le pipe non risiedono su disco ma in un buffer del kernel",
      "I \"file descriptor\" non riconducono a nessun file reale",
      "Le pipe sono oggetti creati dal kernel"
    ],
    "soluzioni": [
      "Le pipe non risiedono su disco ma in un buffer del kernel",
      "I \"file descriptor\" non riconducono a nessun file reale",
      "Le pipe sono oggetti creati dal kernel"
    ]
  },
  {
    "domanda": "La funzione curs_set(1):",
    "opzioni": [
      "Rende visibile il cursore",
      "Rende maggiormente visibile il cursore",
      "Rende invisibile il cursore"
    ],
    "soluzioni": [
      "Rende visibile il cursore"
    ]
  },
  {
    "domanda": "Dire se la seguente affermazione è corretta: \"L'operazione di post incrementa il valore del semaforo di 1, e se il semaforo assumeva precedentemente al post il valore zero e altri thread erano bloccati su di esso con una operazione di wait, uno dei thread viene sbloccato, la sua operazione di wait viene completata e il semaforo ritorna a zero\"",
    "opzioni": [
      "No, non è corretta",
      "Solo l'ultima parte è corretta",
      "Sì, è corretta"
    ],
    "soluzioni": [
      "Sì, è corretta"
    ]
  },
  {
    "domanda": "L'accesso alla pipe in lettura:",
    "opzioni": [
      "Blocca il processo in caso di pipe piena",
      "Blocca il processo in caso di pipe non correttamente inizializzata",
      "Blocca il processo in caso di pipe vuota"
    ],
    "soluzioni": [
      "Blocca il processo in caso di pipe vuota"
    ]
  },
  {
    "domanda": "La system call getppid fornisce",
    "opzioni": [
      "Il PID del processo corrente",
      "Il PID del processo figlio",
      "Il PID del processo genitore"
    ],
    "soluzioni": [
      "Il PID del processo genitore"
    ]
  },
  {
    "domanda": "Il comando make:",
    "opzioni": [
      "Può avvalersi di alcune \"macro\" predefinite",
      "Può avvalersi di alcune \"funzioni\" predefinite",
      "Può avvalersi di un \"metalinguaggio\" per definire le sue direttive"
    ],
    "soluzioni": [
      "Può avvalersi di alcune \"macro\" predefinite"
    ]
  },
  {
    "domanda": "Selezionare le affermazioni NON CORRETTE su \"file descriptor\" e \"pipe\":",
    "opzioni": [
      "Le pipe NON sono oggetti generati dal kernel Linux",
      "Le pipe non riconducono a nessun file reale",
      "\"file descriptor\" sono gestiti tramite un buffer memorizzato sul disco"
    ],
    "soluzioni": [
      "Le pipe NON sono oggetti generati dal kernel Linux"
    ]
  },
  {
    "domanda": "Il seguente comando tr -c A-Za-z0-9 ' '",
    "opzioni": [
      "Sostituisce le stringhe composte da carattere alfabetici (-c = singolo carattere) con caratteri numerici",
      "Sostituisce i caratteri alfanumerici (-c = complement) con spazi",
      "Sostituisce i caratteri non alfanumerici (-c = complement) con spazi"
    ],
    "soluzioni": [
      "Sostituisce i caratteri non alfanumerici (-c = complement) con spazi"
    ]
  },
  {
    "domanda": "Selezionare il corretto prototipo della funzione scanw():",
    "opzioni": [
      "int scanw(x, y, char *fmt [, arg] ...);",
      "int scanw(char *fmt [, arg] ...);",
      "void scanw(char *fmt [, arg] ...);"
    ],
    "soluzioni": [
      "int scanw(char *fmt [, arg] ...);"
    ]
  },
  {
    "domanda": "Convenzionalmente, l'indice 2 (due) dell'array di un file descriptor identifica:",
    "opzioni": [
      "Lo \"standard output\"",
      "Lo \"standard error\"",
      "Lo \"standard input\""
    ],
    "soluzioni": [
      "Lo \"standard error\""
    ]
  },
  {
    "domanda": "Thread e processi condividono le risorse in modo uguale:",
    "opzioni": [
      "Vero",
      "Non vi è condivisione di risorse",
      "Falso"
    ],
    "soluzioni": [
      "Falso"
    ]
  },
  {
    "domanda": "I requisiti da assicurare per la corretta esecuzione delle sezioni critiche di un programma multithreads sono:",
    "opzioni": [
      "Attesa limitata",
      "Mutua esclusione",
      "Sospensione"
    ],
    "soluzioni": [
      "Attesa limitata",
      "Mutua esclusione"
    ]
  },
  {
    "domanda": "Un prompt come \"droms@dedalus:~$ \" ci indica che:",
    "opzioni": [
      "L'utente \"dedalus\" è un amministratore (root) del sistema",
      "L'utente \"droms\" è un utente privilegiato (root)",
      "L'utente non è un utente privilegiato (root)"
    ],
    "soluzioni": [
      "L'utente non è un utente privilegiato (root)"
    ]
  },
  {
    "domanda": "Il cosiddetto \"deadlock\" rappresenta:",
    "opzioni": [
      "Una situazione in cui due o più processi o azioni si alternano in modo indefinito su una determinata azione",
      "Una situazione in cui due o più processi o azioni si bloccano a vicenda, aspettando che uno esegua una certa azione",
      "L'impossibilità continua, da parte di un processo pronto all'esecuzione, di ottenere le risorse di cui necessita per essere eseguito"
    ],
    "soluzioni": [
      "Una situazione in cui due o più processi o azioni si bloccano a vicenda, aspettando che uno esegua una certa azione"
    ]
  },
  {
    "domanda": "I requisiti da assicurare per la corretta esecuzione delle sezioni critiche di un programma multithreads sono:",
    "opzioni": [
      "Mutua esclusione",
      "Progresso",
      "Attesa limitata"
    ],
    "soluzioni": [
      "Mutua esclusione",
      "Progresso",
      "Attesa limitata"
    ]
  },
  {
    "domanda": "Il comando \"make\" è un/uno [1] in grado di assistere il [2] nella fase di sviluppo, tracciando le modifiche effettuate e le [3] tra i vari file, in modo da ricompilare solo quando necessario.",
    "opzioni": [
      "Punto 1: strumento",
      "Punto 2: programmatore",
      "Punto 3: dipendenze"
    ],
    "soluzioni": [
      "Punto 1: strumento",
      "Punto 2: programmatore",
      "Punto 3: dipendenze"
    ]
  },
  {
    "domanda": "In ambito bash che cosa si intende per \"magic number\"?",
    "opzioni": [
      "Il percorso dell'interprete bash, cioè la sua path",
      "Il carattere cancelletto e slash seguito dal percorso dell'interprete bash",
      "Il carattere cancelletto e punto esclamativo seguito dal percorso dell'interprete bash"
    ],
    "soluzioni": [
      "Il carattere cancelletto e punto esclamativo seguito dal percorso dell'interprete bash"
    ]
  },
  {
    "domanda": "Si può accedere ad un semaforo S solo attraverso:",
    "opzioni": [
      "Due operazioni indivisibili",
      "Una operazione atomica singola",
      "Attraverso un mutex"
    ],
    "soluzioni": [
      "Una operazione atomica singola"
    ]
  },
  {
    "domanda": "A chi si riferisce il PID mostrato da queste linee di codice: if(pid == 0){ printf(\"PID: %d\\n\", (int) getppid()); }",
    "opzioni": [
      "Al processo genitore",
      "Al processo figlio",
      "Otteniamo sempre un errore"
    ],
    "soluzioni": [
      "Al processo genitore"
    ]
  },
  {
    "domanda": "Dire se il seguente schema descrittivo del funzionamento delle \"pipe\" è corretto (schema con PROCESSO 1/2 e fork):",
    "opzioni": [
      "Si, lo schema è corretto",
      "Lo schema è corretto ma incompleto",
      "No, lo schema è errato"
    ],
    "soluzioni": [
      "Si, lo schema è corretto"
    ]
  },
  {
    "domanda": "Dire se la seguente affermazione è corretta: \"Per creare un mutex è necessario creare una variabile di tipo pthread_mutex_init e passare un puntatore a questa variabile alla funzione pthread_mutex_t\"",
    "opzioni": [
      "Sì, è corretta",
      "Solo l'ultima parte è corretta",
      "No, non è corretta"
    ],
    "soluzioni": [
      "No, non è corretta"
    ]
  },
  {
    "domanda": "Nella funzione con prototipo \"int init_pair(short pair, short f, short b)\", il parametro \"pair\" può essere:",
    "opzioni": [
      "Un numero intero compreso nell'intervallo da 1 a 7",
      "Un numero intero compreso nell'intervallo da 0 a 7",
      "Un numero intero compreso nell'intervallo da 0 a 2"
    ],
    "soluzioni": [
      "Un numero intero compreso nell'intervallo da 1 a 7"
    ]
  },
  {
    "domanda": "Dire se il seguente frammento di codice è corretto: (for i in 1 2 3 4 5 ... rof)",
    "opzioni": [
      "Dipende dall'interprete",
      "Si",
      "No"
    ],
    "soluzioni": [
      "No"
    ]
  },
  {
    "domanda": "Il comando \"ln\" con l'opzione \"-s\" viene utilizzato per:",
    "opzioni": [
      "Creare un link simbolico",
      "Non esiste l'opzione \"-s\" nel comando \"ln\"",
      "Creare un link fisico"
    ],
    "soluzioni": [
      "Creare un link simbolico"
    ]
  },
  {
    "domanda": "Selezionare l'affermazione corretta tra quelle proposte:",
    "opzioni": [
      "La chiamata di sistema clone(), che copia tutti i sottocontesti senza condividerne alcuno, rappresenta infatti un caso particolare della fork()",
      "La chiamata di sistema fork(), che condivide tutti i contesti può essere considerata un caso particolare di clone()",
      "La chiamata di sistema fork(), che copia tutti i sottocontesti senza condividerne alcuno, rappresenta infatti un caso particolare di clone()"
    ],
    "soluzioni": [
      "La chiamata di sistema fork(), che copia tutti i sottocontesti senza condividerne alcuno, rappresenta infatti un caso particolare di clone()"
    ]
  },
  {
    "domanda": "Dire se la seguente affermazione è corretta: \"Per creare un mutex è necessario creare una variabile di tipo lpmutex e passare un puntatore a questa variabile alla funzione lpmutex_init\"",
    "opzioni": [
      "Sì, è corretta",
      "No, non è corretta",
      "Solo l'ultima parte è corretta"
    ],
    "soluzioni": [
      "No, non è corretta"
    ]
  },
  {
    "domanda": "Il comando \"cmp\" permette di:",
    "opzioni": [
      "Compara due file di qualunque tipo e visualizza il byte e il numero di riga della prima differenza individuata",
      "Compara due file binari e visualizza il solo numero di riga della prima differenza individuata",
      "Confronta due file di qualunque tipo e visualizza la differenza in byte"
    ],
    "soluzioni": [
      "Compara due file di qualunque tipo e visualizza il byte e il numero di riga della prima differenza individuata"
    ]
  },

  {
    "domanda": "Il comando \"mkdir file.txt\":",
    "opzioni": [
      "Crea una nuova directory dal nome \"file.txt\"",
      "Crea un nuovo file dal nome \"file.txt\"",
      "Genera un errore, in quanto si sta cercando di creare un file e non una cartella"
    ],
    "soluzioni": [
      "Crea una nuova directory dal nome \"file.txt\""
    ]
  },
  {
    "domanda": "Una variabile di tipo WINDOWS è:",
    "opzioni": [
      "Un puntatore",
      "Un intero positivo",
      "Un array"
    ],
    "soluzioni": [
      "Un puntatore"
    ]
  },
  {
    "domanda": "Il comando condizionale, di seguito riportato, esegue il comando condition_command e utilizza il suo exit status per decidere se eseguire leistruzioni true_commands (exit status 0) oppure le istruzioni false_commands (exit status non zero)? (if condition_command ...)",
    "opzioni": [
      "No, le true_commands hanno un exit status 1",
      "Si",
      "No, due rami sono invertiti"
    ],
    "soluzioni": [
      "Si"
    ]
  },
  {
    "domanda": "Per ricercare le occorrenze di una o più parole in una serie di file possiamo utilizzare il comando:",
    "opzioni": [
      "grep",
      "info",
      "search"
    ],
    "soluzioni": [
      "grep"
    ]
  },
  {
    "domanda": "Trascinare la corretta istruzione all'interno nel seguente codice: (switch(pid)... default: ...)",
    "opzioni": [
      "wait(0, NULL);",
      "wait(-1, 0, 0);",
      "waitpid((int*)0);",
      "wait((int*)0);"
    ],
    "soluzioni": [
      "wait((int*)0);"
    ]
  },
  {
    "domanda": "L'affermazione \"ogni comando restituisce un exit status. Il successo restituisce 1, il fallimento un codice d'errore\" è corretta?",
    "opzioni": [
      "No, il successo restituisce 0",
      "Sì, è corretta",
      "No, il successo non restituisce nessun valore"
    ],
    "soluzioni": [
      "No, il successo restituisce 0"
    ]
  },
  {
    "domanda": "Dire se è corretta la seguente affermazione: \"Se il padre muore prima di poter fare la wait al processo figlio, quest'ultimo viene ereditato dal processo init, che si occuperà di effettuare la wait\"",
    "opzioni": [
      "Incorretta",
      "Dipende",
      "Corretta"
    ],
    "soluzioni": [
      "Corretta"
    ]
  },
  {
    "domanda": "Job di shell e processo sono la stessa cosa?",
    "opzioni": [
      "Solo nel contesto dell'utilizzo di una pipe",
      "No",
      "Si"
    ],
    "soluzioni": [
      "No"
    ]
  },
  {
    "domanda": "Convenzionalmente, l'indice 1 (uno) dell'array di un file descriptor identifica:",
    "opzioni": [
      "Lo \"standard error\"",
      "Lo \"standard input\"",
      "Lo \"standard output\""
    ],
    "soluzioni": [
      "Lo \"standard output\""
    ]
  },
  {
    "domanda": "La funzione curs_set(2):",
    "opzioni": [
      "Rende maggiormente visibile il cursore",
      "Rende invisibile il cursore",
      "Rende visibile il cursore"
    ],
    "soluzioni": [
      "Rende maggiormente visibile il cursore"
    ]
  },
  {
    "domanda": "Il comando \"cp file_sorgente directory/\":",
    "opzioni": [
      "Copia \"file_sorgente\" all'interno della cartella \"directory/\"",
      "Rinomina \"file_sorgente\" come \"directory/\"",
      "Sposta il \"file_sorgente\" all'interno della cartella \"directory/\""
    ],
    "soluzioni": [
      "Copia \"file_sorgente\" all'interno della cartella \"directory/\""
    ]
  },
  {
    "domanda": "Invocando la funzione printw(), l'output verrà visualizzato:",
    "opzioni": [
      "A partire dalla posizione corrente del cursore",
      "Al centro dello schermo",
      "Nella prima riga dello schermo"
    ],
    "soluzioni": [
      "A partire dalla posizione corrente del cursore"
    ]
  },
  {
    "domanda": "Selezionare le corrette affermazioni riguardo alla system call \"execl\":",
    "opzioni": [
      "Elimina il programma originale, sovrascrivendolo",
      "Le istruzioni che seguono la sua chiamata verranno eseguite soltanto in caso si verifichi un errore",
      "Le istruzioni che seguono la sua chiamata vengono eseguite nel processo padre"
    ],
    "soluzioni": [
      "Elimina il programma originale, sovrascrivendolo",
      "Le istruzioni che seguono la sua chiamata verranno eseguite soltanto in caso si verifichi un errore"
    ]
  },
  {
    "domanda": "Nell'ambito della shell Linux, il prompt rappresenta:",
    "opzioni": [
      "Un carattere o un insieme di caratteri che possono essere personalizzati dall'utente",
      "Un carattere o un insieme di caratteri definiti in fase di installazione del sistema operativo",
      "Una serie di informazioni relative all'utente corrente ed al sistema utilizzato"
    ],
    "soluzioni": [
      "Un carattere o un insieme di caratteri che possono essere personalizzati dall'utente"
    ]
  },
  {
    "domanda": "Un thread può essere definito come:",
    "opzioni": [
      "Nessuna delle risposte è corretta",
      "Uno dei possibili processi che appartengono al gruppo di thread avviabili",
      "Uno dei possibili sottoprocessi che è possibile eseguire all'interno di processo"
    ],
    "soluzioni": [
      "Uno dei possibili sottoprocessi che è possibile eseguire all'interno di processo"
    ]
  },
  {
    "domanda": "Gli elementi che contraddistinguono la struttura di un makefile sono:",
    "opzioni": [
      "\"target\", \"source\" e \"azione\"",
      "\"source\" e \"target\"",
      "\"target\", \"source\", \"azione\" e \"timestamp\""
    ],
    "soluzioni": [
      "\"target\", \"source\" e \"azione\""
    ]
  },
  {
    "domanda": "Nei sistemi Linux, le funzioni dei thread ricevono in ingresso:",
    "opzioni": [
      "Un parametro, di tipo t_pid e uno di tipo void*",
      "Due parametri, di tipo void*",
      "Un solo parametro, di tipo void*"
    ],
    "soluzioni": [
      "Un solo parametro, di tipo void*"
    ]
  },
  {
    "domanda": "Affinchè il debugger GDB possa funzionare:",
    "opzioni": [
      "Occorre compilare il sorgente con l'opzione \"-d\"",
      "Occorre compilare il sorgente con l'opzione \"-gdb\"",
      "Occorre compilare il sorgente con l'opzione \"-g\""
    ],
    "soluzioni": [
      "Occorre compilare il sorgente con l'opzione \"-g\""
    ]
  },
  {
    "domanda": "Per visualizzare le variabili di ambiente si può usare il comando:",
    "opzioni": [
      "echo",
      "env",
      "set"
    ],
    "soluzioni": [
      "env"
    ]
  },
  {
    "domanda": "Un \"semaforo contatore\":",
    "opzioni": [
      "E' un intero che può assumere valori in un dominio limitato",
      "E' un intero che assumere valori sotto il controllo di un mutex binario",
      "E' un intero che può assumere valori in un dominio non limitato"
    ],
    "soluzioni": [
      "E' un intero che può assumere valori in un dominio non limitato"
    ]
  },
  {
    "domanda": "Se un thread esegue un lock con un mutex ed un secondo thread tenta di eseguire un lock sullo stesso mutex:",
    "opzioni": [
      "Il secondo thread ottiene una return e continua l'esecuzione delle successive righe di codice",
      "Il secondo thread viene posto in attesa",
      "Il secondo thread viene terminato"
    ],
    "soluzioni": [
      "Il secondo thread viene posto in attesa"
    ]
  },
  {
    "domanda": "Un programma viene avviato esplicitamente come job in background quando alla fine della riga di comando aggiungiamo il simbolo:",
    "opzioni": [
      "&",
      "2>",
      "|>"
    ],
    "soluzioni": [
      "&"
    ]
  },
  {
    "domanda": "E' possibile specificare i permessi di accesso anche per le directory, così come è possibile per i file?",
    "opzioni": [
      "Dipende dal tipo di directory",
      "Si",
      "No"
    ],
    "soluzioni": [
      "Si"
    ]
  },
  {
    "domanda": "Per visualizzare il contenuto della cartella corrente, devo utlizzare il comando:",
    "opzioni": [
      "ls.",
      "ls",
      "cat"
    ],
    "soluzioni": [
      "ls"
    ]
  },
  {
    "domanda": "Dopo l'avvio di un programma come job in background, la shell restituisce una riga contenente:",
    "opzioni": [
      "Il numero del job e il numero del primo processo generato da questo job (PID)",
      "Solo il PID del primo processo generato da questo job",
      "Non restituisce nulla"
    ],
    "soluzioni": [
      "Il numero del job e il numero del primo processo generato da questo job (PID)"
    ]
  },
  {
    "domanda": "Il comando \"sort -k 2 -n documento.txt\":",
    "opzioni": [
      "Visualizza le prime due righe del file ordinate numericamente",
      "Visualizza il contenuto del file indicato, ordinandolo alfabeticamente sulla base della seconda colonna",
      "Visualizza il contenuto del file indicato, ordinandolo numericamente sulla base della seconda colonna"
    ],
    "soluzioni": [
      "Visualizza il contenuto del file indicato, ordinandolo numericamente sulla base della seconda colonna"
    ]
  },

  {
    "domanda": "Selezionare le corrette affermazioni sui processi nello stato \"zombie\" (o defunct)",
    "opzioni": [
      "Un processo zombie consuma risorse fino alla sua terminazione da parte di init",
      "Un processo diviene zombie dopo essere terminato e prima che il processo padre abbia eseguito una wait per esso",
      "Un processo zombie non consuma risorse"
    ],
    "soluzioni": [
      "Un processo diviene zombie dopo essere terminato e prima che il processo padre abbia eseguito una wait per esso"
    ]
  },
  {
    "domanda": "Il permesso di scrittura su una directory:",
    "opzioni": [
      "Consente di accedere all'interno della directory",
      "Consente di aggiungere nuovi file al suo interno",
      "Consente di elencare tutti i file in essa contenuti"
    ],
    "soluzioni": [
      "Consente di aggiungere nuovi file al suo interno"
    ]
  },
  {
    "domanda": "Riguardo alla shell Linux, selezionare le affermazioni non corrette:",
    "opzioni": [
      "Esistono vari tipi di shell ma da diversi anni è possibile utilizzare solo Bash",
      "Esistono vari tipi di shell",
      "E' possibile configurare il sistema per utilizzare la shell che si preferisce"
    ],
    "soluzioni": [
      "Esistono vari tipi di shell ma da diversi anni è possibile utilizzare solo Bash"
    ]
  },
  {
    "domanda": "Nella funzione con prototipo \"int init_pair(short pair, short f, short b)\", mediante il parametro \"f\" specifichiamo:",
    "opzioni": [
      "Il colore dello sfondo",
      "Il colore del carattere",
      "Il colore dello schermo predefinito"
    ],
    "soluzioni": [
      "Il colore del carattere"
    ]
  },
  {
    "domanda": "La funzione delch():",
    "opzioni": [
      "Cancella l'intera riga su cui si trova il cursore, muovendo in alto le linee che seguono",
      "Cancella il carattere sotto il cursore e sposta i caratteri seguenti ad esso verso sinistra",
      "Sovrascrive con spazi bianchi ogni posizione dello schermo"
    ],
    "soluzioni": [
      "Cancella il carattere sotto il cursore e sposta i caratteri seguenti ad esso verso sinistra"
    ]
  },
  {
    "domanda": "Se il processo padre è terminato:",
    "opzioni": [
      "Il processo \"orfano\" termina ed il suo PID viene comunicato al processo init",
      "Il PPID del processo \"orfano\" viene settato a 1",
      "Il processo \"orfano\" viene adottato da init"
    ],
    "soluzioni": [
      "Il PPID del processo \"orfano\" viene settato a 1",
      "Il processo \"orfano\" viene adottato da init"
    ]
  },
  {
    "domanda": "La system call \"wait\" consente:",
    "opzioni": [
      "la terminazione dei processi aperti",
      "la corretta terminazione dei processi figli",
      "la sincronizzazione fra processi"
    ],
    "soluzioni": [
      "la sincronizzazione fra processi"
    ]
  },
  {
    "domanda": "Dire se la seguente istruzione è sufficiente per inizializzare correttamente un mutex: pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;",
    "opzioni": [
      "La sintassi è incorretta",
      "Sì, è sufficiente",
      "No, non è sufficiente"
    ],
    "soluzioni": [
      "Sì, è sufficiente"
    ]
  },
  {
    "domanda": "Dire se le seguenti system call sono equivalenti: waitpid(-1, &status, 0); wait(&status);",
    "opzioni": [
      "No",
      "Si",
      "La sintassi di waitpid genera un errore"
    ],
    "soluzioni": [
      "Si"
    ]
  },
  {
    "domanda": "Nell'ambito Bash, cosa si intende per \"path\":",
    "opzioni": [
      "Un elenco di directory separato da due punti che configura l'insieme dei percorsi di ricerca dei comandi",
      "Un elenco di comandi all'interno di speciali cartelle di sistema",
      "Un elenco di directory separato da una virgola che indica il percorso dove cercare i comandi"
    ],
    "soluzioni": [
      "Un elenco di directory separato da due punti che configura l'insieme dei percorsi di ricerca dei comandi"
    ]
  },
  {
    "domanda": "Quali sono gli \"operatori di redirezione\" utilizzabili nell'ambito dei canali standard di input/output/error",
    "opzioni": [
      "\"<\", \">\", \">>\" e \"=\"",
      "\"<\" \">\" e \">>\"",
      "\"<\" e \">\""
    ],
    "soluzioni": [
      "\"<\" \">\" e \">>\""
    ]
  },
  {
    "domanda": "Il permesso di lettura su una directory:",
    "opzioni": [
      "Consente di accedere all'interno della directory",
      "Consente di aggiungere nuovi file al suo interno",
      "Consente di elencare tutti i file in essa contenuti"
    ],
    "soluzioni": [
      "Consente di elencare tutti i file in essa contenuti"
    ]
  },
  {
    "domanda": "I permessi di un file si riferiscono:",
    "opzioni": [
      "A 2 categorie di utenti: proprietario e utenti appartenenti gruppo del proprietario",
      "A 4 categorie di utenti: proprietario, utenti appartenenti gruppo del proprietario, utenti del sistema e tutti gli altri utenti",
      "A 3 categorie di utenti: proprietario, utenti appartenenti gruppo del proprietario e tutti gli altri utenti"
    ],
    "soluzioni": [
      "A 3 categorie di utenti: proprietario, utenti appartenenti gruppo del proprietario e tutti gli altri utenti"
    ]
  },
  {
    "domanda": "Le system call execl, execle, execlp, execv e execvp",
    "opzioni": [
      "Richiamano comunque execve, che rappresenta la principale system call della famiglia, cambia solo il modo in cui vengono passati i parametri",
      "Possono essere considerate differenti modalità per effettuare una fork",
      "Richiamano comunque execve, che rappresenta la principale system call della famiglia, cambia solo il modo in cui vengono gestiti i processi"
    ],
    "soluzioni": [
      "Richiamano comunque execve, che rappresenta la principale system call della famiglia, cambia solo il modo in cui vengono passati i parametri"
    ]
  },
  {
    "domanda": "Selezionare le affermazioni corrette:",
    "opzioni": [
      "\"file\" visualizza il contenuto di un file",
      "\"head\" visualizza la prima parte di un file di testo",
      "\"strings\" visualizza stringhe di testo all'interno di un file binario"
    ],
    "soluzioni": [
      "\"head\" visualizza la prima parte di un file di testo",
      "\"strings\" visualizza stringhe di testo all'interno di un file binario"
    ]
  },
  {
    "domanda": "Dopo una chiamata a \"pthread_create\", il nuovo thread inizia la sua esecuzione in modo concorrente ed asincrono",
    "opzioni": [
      "Vero",
      "Dipende dal contesto",
      "Falso"
    ],
    "soluzioni": [
      "Vero"
    ]
  },
  {
    "domanda": "Dire se il seguente prototipo della funzione \"pthread_create\" è corretto: int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void*), void *arg);",
    "opzioni": [
      "E' corretto",
      "Non è corretto",
      "Quello è il prototipo della funzione pthread_clone()"
    ],
    "soluzioni": [
      "E' corretto"
    ]
  },
  {
    "domanda": "I thread possono essere considerati:",
    "opzioni": [
      "Parti di un processo che vengono eseguite in maniera sequenziale",
      "Parti di un processo che vengono eseguite in maniera concorrente",
      "Parti di un processo che vengono eseguite in maniera asincrona"
    ],
    "soluzioni": [
      "Parti di un processo che vengono eseguite in maniera concorrente"
    ]
  },
  {
    "domanda": "Il comando \"whatis\":",
    "opzioni": [
      "Visualizza il tipo di file",
      "Visualizza le pagine di manuale del comando specificato come parametro",
      "Visualizza la breve descrizione di un comando"
    ],
    "soluzioni": [
      "Visualizza la breve descrizione di un comando"
    ]
  },
  {
    "domanda": "L'affermazione \"per accedere ad un file non è sufficiente abilitarne i permessi ma occorre che la directory che lo contiene, così come la directory genitrice e tutte le altre directory padre siano abilitate in esecuzione\" è sempre corretta?",
    "opzioni": [
      "No, mai",
      "Sì, sempre",
      "Sì, ma con qualche eccezione"
    ],
    "soluzioni": [
      "Sì, sempre"
    ]
  },
  {
    "domanda": "I requisiti da assicurare per la corretta esecuzione delle sezioni critiche di un programma multithreads sono:",
    "opzioni": [
      "Mutua esclusione",
      "Progresso",
      "Attesa limitata"
    ],
    "soluzioni": [
      "Mutua esclusione",
      "Progresso",
      "Attesa limitata"
    ]
  },
  {
    "domanda": "Nell'output del comando \"ls -l\", i permessi di accesso al file sono indicati:",
    "opzioni": [
      "Dai 9 caratteri successivi al primo, nelle informazioni di ciascun file",
      "Dai primi 9 caratteri, nelle informazioni di ciascun file",
      "Dai 3 gruppi di 3 caratteri ciascuno che seguono il nome e il gruppo utente, nelle informazioni di ciascun file"
    ],
    "soluzioni": [
      "Dai 9 caratteri successivi al primo, nelle informazioni di ciascun file"
    ]
  },
  {
    "domanda": "Dire se è corretta la seguente affermazione: \"quando eseguiamo un programma, viene creato un nuovo processo ed a esso viene associato un singolo thread\"",
    "opzioni": [
      "L'affermazione NON è corretta",
      "L'affermazione è corretta",
      "L'affermazione è parzialmente corretta"
    ],
    "soluzioni": [
      "L'affermazione è corretta"
    ]
  },
  {
    "domanda": "Selezionare i metodi corretti per effettuare operazioni matematiche nel linguaggio bash:",
    "opzioni": [
      "[[ a=4+1]]",
      "$((a=4+1))",
      "let a=2+3"
    ],
    "soluzioni": [
      "$((a=4+1))",
      "let a=2+3"
    ]
  },
  {
    "domanda": "In ambito ncurses è possibile definire colori in modo arbitrario",
    "opzioni": [
      "Sì, adoperando la funzione rgb_define()",
      "Sì, adoperando la funzione init_color()",
      "No, esistono dei colori predefiniti che si possono usare"
    ],
    "soluzioni": [
      "Sì, adoperando la funzione init_color()"
    ]
  },
  {
    "domanda": "Selezionare l'affermazione NON corretta su \"make\":",
    "opzioni": [
      "Make rappresenta uno strumento generico per l'automazione di procedure",
      "Make è uno strumento specifico per il linguaggio C",
      "Make consente di coinvolgere nel processo di compilazione i soldi file necessari"
    ],
    "soluzioni": [
      "Make è uno strumento specifico per il linguaggio C"
    ]
  },
  {
    "domanda": "Per visualizzare il contenuto di una variabile occorre usare il comando:",
    "opzioni": [
      "echo",
      "env",
      "set"
    ],
    "soluzioni": [
      "echo"
    ]
  },
  {
    "domanda": "Dire se la seguente affermazione è corretta: \"Gli accessi ad una zona critica del codice dovrebbero avvenire tra la chiamata a pthread_mutex_lock e la chiamata a pthread_mutex_unlock\"",
    "opzioni": [
      "No, non è corretta",
      "Non è sempre corretta",
      "Sì, è corretta"
    ],
    "soluzioni": [
      "Sì, è corretta"
    ]
  },
  {
    "domanda": "Nella funzione con prototipo \"int init_pair(short pair, short f, short b)\", mediante il parametro \"b\" specifichiamo:",
    "opzioni": [
      "Il colore della window corrente",
      "Il colore dello sfondo",
      "Il colore del carattere"
    ],
    "soluzioni": [
      "Il colore dello sfondo"
    ]
  },
  {
    "domanda": "Selezionare le corrette affermazioni riguardo alla system call \"fork\":",
    "opzioni": [
      "Padre e figlio condividono la tabella dei file aperti (e quindi anche il puntatore alla locazione corrente di ogni file)",
      "Padre e figlio condividono la tabella dei file aperti (ma non il puntatore alla locazione corrente di ogni file)",
      "Padre e figlio hanno due tabelle dei descrittori di file diverse (il figlio ha una copia di quella del padre)"
    ],
    "soluzioni": [
      "Padre e figlio condividono la tabella dei file aperti (e quindi anche il puntatore alla locazione corrente di ogni file)"
    ]
  },

  {
    "domanda": "La funzione \"sem_getvalue\":",
    "opzioni": [
      "Non esiste questa funzione",
      "Restituisce il valore successivo del semaforo dopo una invocazione di \"sem_trywait\"",
      "Restituisce il valore corrente del semaforo"
    ],
    "soluzioni": [
      "Restituisce il valore corrente del semaforo"
    ]
  },
  {
    "domanda": "Nel processo di compilazione di un file sorgente in ambiente Linux, il passo che coinvolge il \"linker\" ha lo scopo di:",
    "opzioni": [
      "\"verificare\" il codice prima della fase finale di compilazione",
      "\"collegare\" il codice macchina precedentemente prodotto a quello delle funzioni di libreria utilizzate nel programma",
      "\"collegare\" il codice macchina precedentemente compilato a quello delle funzioni di libreria utilizzate nel programma"
    ],
    "soluzioni": [
      "\"collegare\" il codice macchina precedentemente compilato a quello delle funzioni di libreria utilizzate nel programma"
    ]
  },
  {
    "domanda": "Il comando \"cut\" permette di:",
    "opzioni": [
      "Estrarre una parte di un file sulla base di un criterio che potrà essere utilizzata per un altro scopo",
      "Cancellare il contenuto di un file sulla base di un criterio",
      "Dividere il file in più parti sulla base di un criterio"
    ],
    "soluzioni": [
      "Estrarre una parte di un file sulla base di un criterio che potrà essere utilizzata per un altro scopo"
    ]
  },
  {
    "domanda": "Selezionare il corretto prototipo della funzione \"wait\":",
    "opzioni": [
      "pid_t wait(int *status)",
      "pid_t waitpid(pid_t pid, int *status, int options, pid_t ppid)",
      "pid_t waitpid(pid_t pid, int *status, int options)"
    ],
    "soluzioni": [
      "pid_t wait(int *status)"
    ]
  },
  {
    "domanda": "I principali file in un sistema operativo Linux sono:",
    "opzioni": [
      "File regolari, directory, file a caratteri e file a blocchi",
      "File regolari, file di testo, file eseguibili e file a blocchi",
      "File regolari, directory, file a caratteri e file sequenziali"
    ],
    "soluzioni": [
      "File regolari, directory, file a caratteri e file a blocchi"
    ]
  },
  {
    "domanda": "Alcuni vantaggi principali dei thread sono:",
    "opzioni": [
      "Parallelismo reale anzichè emulato",
      "Risparmio di risorse",
      "Tempi di risposta migliori"
    ],
    "soluzioni": [
      "Parallelismo reale anzichè emulato",
      "Risparmio di risorse",
      "Tempi di risposta migliori"
    ]
  },
  {
    "domanda": "Più thread possono essere bloccati contemporaneamente da un mutex in stato di lock",
    "opzioni": [
      "Vero",
      "No, soltanto uno alla volta",
      "Vero, ma non contemporaneamente"
    ],
    "soluzioni": [
      "Vero"
    ]
  },
  {
    "domanda": "Il meccanismo delle \"pipe\"",
    "opzioni": [
      "Nasce con l'avvento di Unix",
      "Si basa su una coppia di \"file descriptor\"",
      "Si adopera per creare una canale di comunicazione"
    ],
    "soluzioni": [
      "Nasce con l'avvento di Unix",
      "Si basa su una coppia di \"file descriptor\"",
      "Si adopera per creare una canale di comunicazione"
    ]
  },
  {
    "domanda": "La funzione che consente di assegnare variabili da standard input in uno script bash è:",
    "opzioni": [
      "La funzione \"read\"",
      "La funzione \"readchar\"",
      "La funzione \"get\""
    ],
    "soluzioni": [
      "La funzione \"read\""
    ]
  },
  {
    "domanda": "L'operatore di \"pipe\", che consente di collegare l'output standard di un comando all'input standard di un secondo comando, viene definito dal carattere:",
    "opzioni": [
      "|",
      "&",
      ">"
    ],
    "soluzioni": [
      "|"
    ]
  },
  {
    "domanda": "Valutare la correttezza dell'affermazione \"l'accesso concorrente a dati condivisi può provocare l'inconsistenza dei dati stessi, in mancanza di strumenti di gestione opportuni\"",
    "opzioni": [
      "L'affermazione è corretta",
      "L'affermazione non è corretta",
      "L'affermazione è corretta parzialmente"
    ],
    "soluzioni": [
      "L'affermazione è corretta"
    ]
  },
  {
    "domanda": "Il carattere speciale \"..\" identifica:",
    "opzioni": [
      "La directory che si trova al livello immediatamente superiore",
      "La directory corrente",
      "Tutte le directory che si trovano al livello immediatamente superiore"
    ],
    "soluzioni": [
      "La directory che si trova al livello immediatamente superiore"
    ]
  },
  {
    "domanda": "L'affermazione \"Dopo una fork il processo figlio condivide gli stessi file descriptor del padre, compresi quelli associati ad una pipe\" è corretta?",
    "opzioni": [
      "Si",
      "Si, eccetto quel che riguarda la pipe",
      "No"
    ],
    "soluzioni": [
      "Si"
    ]
  },
  {
    "domanda": "Se un thread chiude un file descriptor, gli altri thread:",
    "opzioni": [
      "Non sono più in grado di accedere al file in lettura o scrittura",
      "Sono in grado di accedere al file in sola lettura",
      "Sono comunque in grado di accedere al file in lettura o scrittura"
    ],
    "soluzioni": [
      "Non sono più in grado di accedere al file in lettura o scrittura"
    ]
  },
  {
    "domanda": "Indicare la prima riga che identifica uno script in linguaggio bash",
    "opzioni": [
      "#!/bash",
      "#/bin/bash",
      "#!/bin/bash"
    ],
    "soluzioni": [
      "#!/bin/bash"
    ]
  },
  {
    "domanda": "Selezionare il corretto prototipo della funzione \"waitpid\":",
    "opzioni": [
      "pid_t waitpid(pid_t pid, int *status, int options, pid_t ppid)",
      "pid_t waitpid(pid_t pid, int *status, int options)",
      "pid_t waitpid(pid_t pid, int *status)"
    ],
    "soluzioni": [
      "pid_t waitpid(pid_t pid, int *status, int options)"
    ]
  },
  {
    "domanda": "Un mutex può essere considerato come:",
    "opzioni": [
      "Una sorta di semaforo binario controllato dal kernel per amministratre l'accesso alle zone critiche",
      "Una sorta di blocco che solo un thread alla volta può inserire o rimuovere.",
      "Una sorta di contatore intero che solo un thread può incrementare o decrementare"
    ],
    "soluzioni": [
      "Una sorta di semaforo binario controllato dal kernel per amministratre l'accesso alle zone critiche"
    ]
  },
  {
    "domanda": "Quando un job viene sospeso, la shell genera una riga del tipo:",
    "opzioni": [
      "[1]+ Stopped nomejob",
      "[1] 134",
      "Non viene mostrata alcuna informazione in shell"
    ],
    "soluzioni": [
      "[1]+ Stopped nomejob"
    ]
  },
  {
    "domanda": "La funzione endwin() di ncurses:",
    "opzioni": [
      "Cancella lo schermo",
      "Termina l'utilizzo della libreria ncurses",
      "Chiude la finestra specificata"
    ],
    "soluzioni": [
      "Termina l'utilizzo della libreria ncurses"
    ]
  },
  {
    "domanda": "Una commutazione fra thread di tipo kernel-level:",
    "opzioni": [
      "Richiede l'impiego di sistemi multiprocessore",
      "Richiede l'impiego di system call, ma un eventuale problema si ripercuote sugli altri threads",
      "Richiede l'impiego di system call, ma un eventuale problema su un thread non si ripercuote sugli altri threads"
    ],
    "soluzioni": [
      "Richiede l'impiego di system call, ma un eventuale problema su un thread non si ripercuote sugli altri threads"
    ]
  },
  {
    "domanda": "Per i programmi C, le system call si comportano come:",
    "opzioni": [
      "Meccanismi di gestione",
      "Funzioni",
      "Processi"
    ],
    "soluzioni": [
      "Funzioni"
    ]
  },
  {
    "domanda": "La funzione erase():",
    "opzioni": [
      "Sovrascrive con il carattere specificato ogni posizione dello schermo",
      "Sovrascrive con spazi bianchi ogni posizione dello schermo, cancellandolo",
      "Cancella l'intera riga su cui si trova il cursore, muovendo in alto le linee che seguono"
    ],
    "soluzioni": [
      "Sovrascrive con spazi bianchi ogni posizione dello schermo, cancellandolo"
    ]
  },
  {
    "domanda": "I thread argument:",
    "opzioni": [
      "Rappresentano una tecnica efficiente per il passaggio dei dati ai threads",
      "Vengono restituiti dalla funzione di creazione dei threads",
      "Rappresentano una tecnica efficiente per la creazione dei threads"
    ],
    "soluzioni": [
      "Rappresenta una tecnica efficiente per il passaggio dei dati ai threads"
    ]
  },
  {
    "domanda": "Supponiamo ora di voler salvare l'elenco dei nomi dei file presenti nella directory corrente all'interno di un file denominato elenco.txt, quale diquesti comandi occorre utilizzare:",
    "opzioni": [
      "Soltanto \"ls >> elenco.txt\"",
      "\"ls > elenco.txt\" oppure \"ls >> elenco.txt\"",
      "Soltanto \"ls > elenco.txt\""
    ],
    "soluzioni": [
      "\"ls > elenco.txt\" oppure \"ls >> elenco.txt\""
    ]
  },
  {
    "domanda": "L'esecuzione del comando \"cd\" senza alcun parametro ha come risultato:",
    "opzioni": [
      "Il comando \"cd\" senza parametri genera un errore, in quanto occorre specificare almeno un argomento",
      "Il comando \"cd\" senza parametri non genera alcun risultato",
      "Il comando \"cd\" senza parametri posiziona l'utente all'interno della sua home directory"
    ],
    "soluzioni": [
      "Il comando \"cd\" senza parametri posiziona l'utente all'interno della sua home directory"
    ]
  },
  {
    "domanda": "Dire se la seguente affermazione è corretta: \"Per creare un mutex è necessario creare una variabile di tipo pthread_mutex_t e passare un puntatore a questa variabile alla funzione pthread_mutex_init\"",
    "opzioni": [
      "Solo la prima parte è corretta",
      "No, non è corretta",
      "Sì, è corretta"
    ],
    "soluzioni": [
      "No, non è corretta"
    ]
  },
  {
    "domanda": "Il linguaggio C può essere considerato:",
    "opzioni": [
      "Un linguaggio procedurale",
      "Un linguaggio interpretato",
      "Un linguaggio basato su classi ed oggetti"
    ],
    "soluzioni": [
      "Un linguaggio procedurale"
    ]
  },
  {
    "domanda": "Il modo di specificare i permessi di accesso di un file, tramite il comando chmod, che utilizza i simboli r, w e x viene definito:",
    "opzioni": [
      "Simbolico",
      "Ottale",
      "Ottale/binario"
    ],
    "soluzioni": [
      "Simbolico"
    ]
  },

  {
    "domanda": "I requisiti da assicurare per la corretta esecuzione delle sezioni critiche di un programma multithreads sono:",
    "opzioni": [
      "Sospensione",
      "Attesa limitata",
      "Mutua esclusione"
    ],
    "soluzioni": [
      "Attesa limitata",
      "Mutua esclusione"
    ]
  },
  {
    "domanda": "Se ciascun thread user-level è mappato su un kernel thread, il massimo numero di thread gestibili dipende:",
    "opzioni": [
      "Un thread user-level NON può essere mappato su un kernel thread",
      "Dal massimo numero di processi gestibili dal kernel",
      "Dal massimo numero di kernel thread gestibili dal kernel"
    ],
    "soluzioni": [
      "Dal massimo numero di kernel thread gestibili dal kernel"
    ]
  },
  {
    "domanda": "In GDB, un breakpoint può essere specificato con il comando:",
    "opzioni": [
      "Con il comando breakpoint, stop, o con la lettera \"b\", seguiti dal numero di riga o dal nome della funzione",
      "Con il comando breakpoint, break, o con la lettera \"b\", seguiti dal numero di riga o dal nome della funzione",
      "Con il comando breakpoint, break, o con la lettera \"r\", seguiti dal numero di riga o dal nome della funzione"
    ],
    "soluzioni": [
      "Con il comando breakpoint, break, o con la lettera \"b\", seguiti dal numero di riga o dal nome della funzione"
    ]
  },
  {
    "domanda": "Il thread principale può creare nuovi thread, i quali eseguono lo stesso programma in:",
    "opzioni": [
      "Modo concorrente all'interno dello stesso processo",
      "Modo concorrente all'interno dello stesso thread",
      "Modo sincrono all'interno dello stesso processo"
    ],
    "soluzioni": [
      "Modo concorrente all'interno dello stesso processo"
    ]
  },
  {
    "domanda": "La funzione in grado di modificare il colore di sfondo dell'intera area di output è:",
    "opzioni": [
      "stdscr()",
      "attron()",
      "bkgd()"
    ],
    "soluzioni": [
      "bkgd()"
    ]
  },
  {
    "domanda": "Selezionare le corrette affermazioni riguardo alla funzione \"exit()\":",
    "opzioni": [
      "Chiude tutti i descrittori di file",
      "Invia un segnale SIGCHLD al processo figlio",
      "Libera lo spazio di indirizzamento"
    ],
    "soluzioni": [
      "Chiude tutti i descrittori di file",
      "Invia un segnale SIGCHLD al processo figlio",
      "Libera lo spazio di indirizzamento"
    ]
  },
  {
    "domanda": "Selezionare le corrette affermazioni riguardo al seguente prototipo della system call \"execl\": int execl(char *pathname, char *arg0, ...);",
    "opzioni": [
      "Il pathname è seguito da una lista di variabili che contengono un puntatore ad una stringa di caratteri",
      "Il pathname è seguito da una lista di variabili che contengono un \"argv\" del nuovo programma eseguito",
      "Il pathname rappresenta il comando da eseguire con specificato il suo percorso completo"
    ],
    "soluzioni": [
      "Il pathname è seguito da una lista di variabili che contengono un puntatore ad una stringa di caratteri",
      "Il pathname rappresenta il comando da eseguire con specificato il suo percorso completo"
    ]
  },
  {
    "domanda": "Il comando \"rmdir nome_directory\":",
    "opzioni": [
      "Rinomina la cartella \"nome_directory\"",
      "Rimuove la cartella \"nome_directory\" se questa è vuota",
      "Rimuove la cartella \"nome_directory\" e tutti i file in essa contenuti"
    ],
    "soluzioni": [
      "Rimuove la cartella \"nome_directory\" se questa è vuota"
    ]
  },
  {
    "domanda": "Nell'ambito delle system call \"wait\" e \"waitpid\", con WIFEXITED(status) otteniamo:",
    "opzioni": [
      "Accediamo al valore restituito dalla \"exit\"",
      "Un valore di tipo True se il processo termina normalmente",
      "Accediamo al valore restituito dalla \"wait\""
    ],
    "soluzioni": [
      "Un valore di tipo True se il processo termina normalmente"
    ]
  },
  {
    "domanda": "Nell'ambito delle system call \"wait\" e \"waitpid\", con WEXITSTATUS(status):",
    "opzioni": [
      "Otteniamo un valore di tipo True se il processo termina normalmente",
      "Accediamo al valore restituito dalla \"wait\"",
      "Accediamo al valore restituito dalla \"exit\""
    ],
    "soluzioni": [
      "Accediamo al valore restituito dalla \"exit\""
    ]
  },
  {
    "domanda": "Durante l'esecuzione di più threads vengono condivise:",
    "opzioni": [
      "Non viene condiviso nulla",
      "Le medesime informazioni di stato",
      "La memoria ed altre risorse di sistema"
    ],
    "soluzioni": [
      "La memoria ed altre risorse di sistema"
    ]
  },
  {
    "domanda": "Quali caratteri si utilizzano per redirezionare lo standard error?",
    "opzioni": [
      "1>",
      "&2",
      "2>"
    ],
    "soluzioni": [
      "2>"
    ]
  },
  {
    "domanda": "La \"race condition\" è:",
    "opzioni": [
      "Una situazione nella quale un processo o thread legge o scrive dei dati e il risultato finale dipende dalla sua tempistica",
      "Una situazione nella quale due o più programmi leggono o scrivono dei dati condivisi, ed il risultato finale dipende dalle loro tempistiche",
      "Una situazione nella quale due o più processi leggono o scrivono dei dati condivisi, ed in tale contesto il risultato finale dipende dalle loro tempistiche"
    ],
    "soluzioni": [
      "Una situazione nella quale due o più processi leggono o scrivono dei dati condivisi, ed in tale contesto il risultato finale dipende dalle loro tempistiche"
    ]
  },
  {
    "domanda": "I comando \"mv file_sorgente file_destinazione\":",
    "opzioni": [
      "Sposta il \"file_sorgente\" su \"file_destinazione\"",
      "Copia \"file_sorgente\" in \"file_destinazione\"",
      "Rinomina \"file_sorgente\" in \"file_destinazione\""
    ],
    "soluzioni": [
      "Rinomina \"file_sorgente\" in \"file_destinazione\""
    ]
  },
  {
    "domanda": "Il modello di multithreading Many-to-Many consente che:",
    "opzioni": [
      "Molti user level threads siano mappati su molti kernel threads",
      "Un user level thread possa essere eseguito mediante diversi kernel threads",
      "Non esiste questo modello di multithreading"
    ],
    "soluzioni": [
      "Molti user level threads siano mappati su molti kernel threads"
    ]
  },
  {
    "domanda": "In un sistema Linux, i comandi possono essere correttamente definiti come:",
    "opzioni": [
      "Programmi contenuti all'interno di alcune directory speciali",
      "I soli programmi contenuti all'interno della directory \"/bin\"",
      "Istruzioni sequenziali definite dagli utenti del sistema"
    ],
    "soluzioni": [
      "Programmi contenuti all'interno di alcune directory speciali"
    ]
  },
  {
    "domanda": "Il permesso di esecuzione su una directory:",
    "opzioni": [
      "Consente di aggiungere nuovi file al suo interno",
      "Consente di elencare tutti i file in essa contenuti",
      "Consente di accedere all'interno della directory"
    ],
    "soluzioni": [
      "Consente di accedere all'interno della directory"
    ]
  },
  {
    "domanda": "Per modificare i permessi di accesso di un file occorre usare il comando:",
    "opzioni": [
      "chown",
      "ls -l-change",
      "chmod"
    ],
    "soluzioni": [
      "chmod"
    ]
  },
  {
    "domanda": "Selezionare l'affermazione corretta su \"make\":",
    "opzioni": [
      "Make può soltanto automatizzare procedure relative al linguaggio C",
      "Make rappresenta uno strumento generico per l'automatizzazione di procedure",
      "Make rappresenta uno strumento specifico per l'automatizzazione di procedure"
    ],
    "soluzioni": [
      "Make rappresenta uno strumento generico per l'automatizzazione di procedure"
    ]
  },
  {
    "domanda": "Quali tra queste affermazioni sul linguaggio C è vera:",
    "opzioni": [
      "Il linguaggio C non consente al programmatore di allocare/deallocare blocchi di memoria",
      "Il linguaggio C consente al programmatore di allocare/deallocare blocchi di memoria",
      "Il linguaggio C consente al programmatore di allocare blocchi di memoria, occupandosi automaticamente di deallocarli al termine del loro utilizzo"
    ],
    "soluzioni": [
      "Il linguaggio C consente al programmatore di allocare/deallocare blocchi di memoria"
    ]
  },
  {
    "domanda": "Il comando \"wc -w miofile\":",
    "opzioni": [
      "Visualizza il numero di righe in \"miofile\"",
      "Visualizza diverse informazioni riguardo al file \"miofile\"",
      "Visualizza il numero delle parole in \"miofile\""
    ],
    "soluzioni": [
      "Visualizza il numero delle parole in \"miofile\""
    ]
  },
  {
    "domanda": "L'esecuzione del comando \"chown dax elenco.txt\" ha come risultato di:",
    "opzioni": [
      "Cambiare in \"dax\" il proprietario del file \"elenco.txt\"",
      "Genera un errore, in quanto l'ordine degli argomenti è errato",
      "Genera un errore, in quanto la sintassi è errata"
    ],
    "soluzioni": [
      "Cambiare in \"dax\" il proprietario del file \"elenco.txt\""
    ]
  },
  {
    "domanda": "Nei sistemi Linux, le funzioni dei thread restituiscono in uscita:",
    "opzioni": [
      "Non restituiscono nulla se non si verifica un errore, altrimenti restituiscono un valore negativo",
      "Un valore di tipo void*",
      "Un valore di tipo int"
    ],
    "soluzioni": [
      "Un valore di tipo void*"
    ]
  },

  {
    "domanda": "Le informazioni visualizzate a video vengono veicolate tramite un canale definito:",
    "opzioni": [
      "Standard input",
      "Standard output",
      "Standard view"
    ],
    "soluzioni": [
      "Standard output"
    ]
  },
  {
    "domanda": "Quale di queste affermazioni sul comando \"sort\" è corretta:",
    "opzioni": [
      "Il comando \"sort\" tratta ogni linea attraverso l'impiego di un differente linguaggio regolare",
      "Il comando \"sort\" tratta ogni linea come una collezione di vari campi separati da delimitatori",
      "Il comando \"sort\" tratta ogni linea come un insieme di campi omogenei"
    ],
    "soluzioni": [
      "Il comando \"sort\" tratta ogni linea come una collezione di vari campi separati da delimitatori"
    ]
  },
  {
    "domanda": "L'invocazione della system call \"pipe\":",
    "opzioni": [
      "Crea un file descriptor associato ad una pipe",
      "Crea una coppia di file descriptor associati ad una pipe",
      "Restituisce 0 in caso di successo e -1 in caso di errore"
    ],
    "soluzioni": [
      "Crea una coppia di file descriptor associati ad una pipe"
    ]
  },
  {
    "domanda": "La commutazione fra thread di tipo user-level:",
    "opzioni": [
      "Non richiede l'intervento del sistema operativo",
      "E' più lenta rispetto a quanto avviene nei processi",
      "Richiede l'intervento del sistema operativo"
    ],
    "soluzioni": [
      "Non richiede l'intervento del sistema operativo"
    ]
  },
  {
    "domanda": "Per accedere al valore contenuto in una variabile bash, devo:",
    "opzioni": [
      "Premettere ad essa il simbolo $",
      "Utilizzare la command substitution",
      "Farla seguire dal simbolo $"
    ],
    "soluzioni": [
      "Premettere ad essa il simbolo $"
    ]
  },
  {
    "domanda": "Per eseguire i thread a livello utente:",
    "opzioni": [
      "Occorre associare loro dei thread a livello kernel mediante un modello di multithreading",
      "Occorre associare loro dei processi a livello kernel mediante un modello di multithreading",
      "Occorre associare loro un thread a livello kernel mediante un modello One-to-many"
    ],
    "soluzioni": [
      "Occorre associare loro dei thread a livello kernel mediante un modello di multithreading"
    ]
  },
  {
    "domanda": "Selezionare l'affermazione vera:",
    "opzioni": [
      "Thread e processi possono convivere se attivati mediante la system call fork() invece che clone()",
      "Un thread esiste all'interno di un processo",
      "Un processo esiste all'interno di un thread"
    ],
    "soluzioni": [
      "Un thread esiste all'interno di un processo"
    ]
  },
  {
    "domanda": "Completare in modo corretto il seguente codice bash: (if ! cd $nd 2> /dev/null ...)",
    "opzioni": [
      "Spazio 1: ! cd",
      "Spazio 2: /dev/null"
    ],
    "soluzioni": [
      "! cd",
      "/dev/null"
    ]
  },
  {
    "domanda": "Il cosiddetto \"starvation\" rappresenta:",
    "opzioni": [
      "l'impossibilità continua, da parte di un processo pronto all'esecuzione, di ottenere le risorse di cui necessita per essere eseguito",
      "Una situazione in cui due o più processi o azioni si bloccano a vicenda, aspettando che uno esegua una certa azione",
      "Una situazione in cui due o più processi o azioni si alternano in modo indefinito su una determinata azione"
    ],
    "soluzioni": [
      "l'impossibilità continua, da parte di un processo pronto all'esecuzione, di ottenere le risorse di cui necessita per essere eseguito"
    ]
  },
  {
    "domanda": "Valutare la correttezza dell'affermazione \"il kernel è la parte di Linux che corrisponde al sistema operativo vero e proprio; esso gestisce sia i processi sia le funzioni di input/output\"",
    "opzioni": [
      "L'affermazione non è corretta",
      "L'affermazione è corretta parzialmente",
      "L'affermazione è corretta"
    ],
    "soluzioni": [
      "L'affermazione è corretta"
    ]
  },
  {
    "domanda": "In ambiente Linux, i file core rappresentano il risultato di:",
    "opzioni": [
      "Un \"buffer Overflow\"",
      "Un errore verificatosi durante un processo di debug",
      "Una \"segmention fault\""
    ],
    "soluzioni": [
      "Una \"segmention fault\""
    ]
  },
  {
    "domanda": "Quali di queste affermazioni sui link simbolici è corretta?",
    "opzioni": [
      "Un link simbolico non dipende dal file originale e nel momento in cui viene cancellato il file sorgente, il collegamento punterà comunque ad esso",
      "Un link simbolico dipende dal filesystem ed è possibile crearlo solo nell'ambito di filesystem di tipo EXT3 o EXT4",
      "Un link simbolico dipende dal file originale e nel momento in cui viene cancellato il file sorgente, il collegamento non punterà più a nulla"
    ],
    "soluzioni": [
      "Un link simbolico dipende dal file originale e nel momento in cui viene cancellato il file sorgente, il collegamento non punterà più a nulla"
    ]
  },
  {
    "domanda": "In GDB, per visualizzare la lista dei breakpoint attivi possiamo usare il comando/comandi:",
    "opzioni": [
      "info breakpoints",
      "list break",
      "info break"
    ],
    "soluzioni": [
      "info break"
    ]
  },
  {
    "domanda": "La funzione \"sem_trywait\":",
    "opzioni": [
      "Non esiste questa funzione",
      "E' la funzione di wait bloccante",
      "E' una funzione di wait non bloccante"
    ],
    "soluzioni": [
      "E' una funzione di wait non bloccante"
    ]
  },
  {
    "domanda": "Il termine \"parametro\" sulla base della documentazione Bash identifica le seguenti entità:",
    "opzioni": [
      "Parametri posizionali, parametri speciali e variabili di shell",
      "Parametri posizionali e parametri speciali",
      "Parametri utente, parametri posizionali e variabili speciali"
    ],
    "soluzioni": [
      "Parametri posizionali, parametri speciali e variabili di shell"
    ]
  },
  {
    "domanda": "Verificare la correttezza della seguente affermazione: \"Se utilizziamo un valore negativo come unico parametro della funzione timeout(), il programma opera secondo il comportamento standard, cioè con getch() si attende l'input dell'utente per un tempo indefinito\"",
    "opzioni": [
      "L'affermazione è parzialmente corretta",
      "L'affermazione è corretta",
      "L'affermazione è incorretta"
    ],
    "soluzioni": [
      "L'affermazione è corretta"
    ]
  },
  {
    "domanda": "Per visualizzare le informazioni circa righe, parole e dimensione in Byte di un file denominato \"miofile\", devo eseguire:",
    "opzioni": [
      "wc -all miofile",
      "wc -cw miofile",
      "wc miofile"
    ],
    "soluzioni": [
      "wc miofile"
    ]
  },
  {
    "domanda": "La funzione noecho() consente di:",
    "opzioni": [
      "Visualizzare sullo schermo i caratteri digitati in fase di input",
      "Cancellare i caratteri sulla riga corrente",
      "Non visualizzare sullo schermo i caratteri digitati in fase di input"
    ],
    "soluzioni": [
      "Non visualizzare sullo schermo i caratteri digitati in fase di input"
    ]
  },
  {
    "domanda": "In ncurses l'angolo in alto a sinistra ha coordinate:",
    "opzioni": [
      "(x=0, y=0)",
      "(x=0, y=LINES)",
      "(x=COLS, y=LINES)"
    ],
    "soluzioni": [
      "(x=0, y=0)"
    ]
  },
  {
    "domanda": "Nell'ambito dell'associazione dei thread a livello kernel, selezionare i modelli di multithreading possibili:",
    "opzioni": [
      "One-to-One",
      "Many-to-Many",
      "Many-to-One"
    ],
    "soluzioni": [
      "One-to-One",
      "Many-to-Many",
      "Many-to-One"
    ]
  },
  {
    "domanda": "La funzione echo() consente di:",
    "opzioni": [
      "Visualizzare sullo schermo i caratteri digitati in fase di input",
      "Non visualizzare sullo schermo i caratteri digitati in fase di input",
      "Cancellare i caratteri presenti sullo schermo"
    ],
    "soluzioni": [
      "Visualizzare sullo schermo i caratteri digitati in fase di input"
    ]
  },
  {
    "domanda": "Dire se è corretta la seguente affermazione: \"Una volta creato, ciascun thread invoca una funzione che contiene il codice che deve eseguire\"",
    "opzioni": [
      "L'affermazione è corretta",
      "L'affermazione NON è corretta",
      "L'affermazione è parzialmente corretta"
    ],
    "soluzioni": [
      "L'affermazione è corretta"
    ]
  },
  {
    "domanda": "La funzione deleteln():",
    "opzioni": [
      "Cancella le linee che seguono il cursore",
      "Cancella l'intera riga su cui si trova il cursore, muovendo in alto le linee che seguono",
      "Sovrascrive con spazi bianchi ogni linea dello schermo"
    ],
    "soluzioni": [
      "Cancella l'intera riga su cui si trova il cursore, muovendo in alto le linee che seguono"
    ]
  },
  {
    "domanda": "Se un thread del processo esegue una exec:",
    "opzioni": [
      "Lo spazio di indirizzamento di tutti gli altri threads non viene sovrascritto dal nuovo processo invocato",
      "Non è possibile effettuare una exec in ambito thread",
      "Anche lo spazio di indirizzamento di tutti gli altri threads viene sovrascritto dal nuovo processo invocato"
    ],
    "soluzioni": [
      "Anche lo spazio di indirizzamento di tutti gli altri threads viene sovrascritto dal nuovo processo invocato"
    ]
  },
  {
    "domanda": "Selezionare le affermazioni corrette riguardo ai nomi di file in ambito filesystem Linux:",
    "opzioni": [
      "Può essere lungo al massimo 256 caratteri",
      "Può contenere caratteri particolari come punti interrogativi o asterischi",
      "Può contenere caratteri alfabetici, numeri, caratteri di sottolineatura o di punteggiatura"
    ],
    "soluzioni": [
      "Può essere lungo al massimo 256 caratteri",
      "Può contenere caratteri alfabetici, numeri, caratteri di sottolineatura o di punteggiatura"
    ]
  },
  {
    "domanda": "La WEXITSTATUS (status) ritorna un valore di tipo:",
    "opzioni": [
      "TRUE, se il processo non termina normalmente",
      "TRUE, se il processo termina normalmente",
      "FALSE, se il processo termina normalmente"
    ],
    "soluzioni": [
      "TRUE, se il processo termina normalmente"
    ]
  },
  {
    "domanda": "Un file che può essere letto, modificato ed eseguito da qualsiasi utente del sistema, visualizzate le informazioni tramite il comando \"ls -l\", sarà caratterizzato nei permessi da una stringa del tipo:",
    "opzioni": [
      "all all all",
      "+++++++++",
      "rwxrwxrwx"
    ],
    "soluzioni": [
      "rwxrwxrwx"
    ]
  },
  {
    "domanda": "Completare in modo corretto il seguente frammento di codice bash: (if [ $1 > 100 ]; ... elif ...)",
    "opzioni": [
      ">",
      "elif"
    ],
    "soluzioni": [
      ">",
      "elif"
    ]
  },
  {
    "domanda": "Nell'ambito di una shell Linux, i tasti Ctrl-A e Ctrl-E:",
    "opzioni": [
      "Aggiungono e tolgono caratteri dalla linea di comando",
      "Consentono di scorrere la history",
      "Muovono il cursore all'inizio ed alla fine della linea di comando"
    ],
    "soluzioni": [
      "Muovono il cursore all'inizio ed alla fine della linea di comando"
    ]
  },
  {
    "domanda": "Il comando \"tr\" permette di:",
    "opzioni": [
      "Modificare o cancellare caratteri da uno stream di input",
      "Tradurre stringhe di testo in italiano da uno stream di input usando un dizionario di default",
      "Modificare o cancellare caratteri da uno stream di output"
    ],
    "soluzioni": [
      "Modificare o cancellare caratteri da uno stream di input"
    ]
  },
  {
    "domanda": "DDD può essere considerato:",
    "opzioni": [
      "Un software di visualizzazione delle informazioni del debugger \"gdb\"",
      "Uno strumento di debugging non interattivo",
      "Un front-end grafico per il debugger \"gdb\""
    ],
    "soluzioni": [
      "Un front-end grafico per il debugger \"gdb\""
    ]
  },
  {
    "domanda": "In caso di successo, i processi padre e figlio iniziano la loro esecuzione dopo la system call fork()",
    "opzioni": [
      "Corretto",
      "No, inizia prima il padre",
      "No, inizia prima il figlio"
    ],
    "soluzioni": [
      "Corretto"
    ]
  },
  {
    "domanda": "L'accesso alla pipe in scrittura:",
    "opzioni": [
      "Blocca il processo in caso di pipe non correttamente inizializzata",
      "Blocca il processo in caso di pipe vuota",
      "Blocca il processo in caso di pipe piena"
    ],
    "soluzioni": [
      "Blocca il processo in caso di pipe piena"
    ]
  },
  {
    "domanda": "Il comando \"rmdir file.txt\":",
    "opzioni": [
      "Non genera un errore ma non cancella \"file.txt\"",
      "Rimuove iil file \"file.txt\", in quanto mkdir funziona sia su file sia su cartelle",
      "Genera un errore, in quanto \"file.txt\", è un file e non una cartella"
    ],
    "soluzioni": [
      "Genera un errore, in quanto \"file.txt\", è un file e non una cartella"
    ]
  },
  {
    "domanda": "Affinchè una variabile sia visibile all'interno di qualsiasi shell:",
    "opzioni": [
      "Occorre esportarla mediante il comando \"export\"",
      "Occorre esportarla mediante il comando \"echo\"",
      "Occorre esportarla mediante il comando \"set\""
    ],
    "soluzioni": [
      "Occorre esportarla mediante il comando \"export\""
    ]
  },
  {
    "domanda": "In una maschera binaria le tre categorie di utenti ossia le tre terne di simboli diventano 3 cifre in formato:",
    "opzioni": [
      "Ottale",
      "Binario",
      "Decimale"
    ],
    "soluzioni": [
      "Ottale"
    ]
  },
  {
    "domanda": "Se mi trovo nella cartella \"due\" del percorso \"/home/pippo/uno/due/tre/dati\", è possibile spostarsi all'interno della cartella \"dati\" utilizzando il comando \"cd tre/dati\":",
    "opzioni": [
      "Sì. Il comando è corretto",
      "No. il comando viene eseguito solo parzialmente",
      "No, il comando deve necessariamente includere anche le cartelle \"/home/pippo/uno\""
    ],
    "soluzioni": [
      "Sì. Il comando è corretto"
    ]
  },
  {
    "domanda": "Le espressioni regolari (RE) si avvalgono di:",
    "opzioni": [
      "Pattern matching languages",
      "Metadati e modificatori",
      "Metacaratteri e modificatori"
    ],
    "soluzioni": [
      "Metacaratteri e modificatori"
    ]
  },
  {
    "domanda": "Per cambiare il proprietario di un file occorre usare il comando:",
    "opzioni": [
      "chmod -u",
      "chown",
      "chmod"
    ],
    "soluzioni": [
      "chown"
    ]
  },
  {
    "domanda": "La funzione \"pthread_join\":",
    "opzioni": [
      "Termina uno specifico thread",
      "Serve per attendere la terminazione di un thread",
      "Prende in ingresso 2 argomenti"
    ],
    "soluzioni": [
      "Serve per attendere la terminazione di un thread"
    ]
  },
  {
    "domanda": "La radice dell'albero dei processi in un sistema Linux viene definita:",
    "opzioni": [
      "init",
      "root",
      "main"
    ],
    "soluzioni": [
      "init"
    ]
  },
  {
    "domanda": "L'esecuzione del comando \"ls\" senza parametri visualizza tutti i file e directory all'interno della directory corrente:",
    "opzioni": [
      "Si",
      "No",
      "Sì, ad eccezione di quelli nascosti"
    ],
    "soluzioni": [
      "Sì, ad eccezione di quelli nascosti"
    ]
  },
  {
    "domanda": "L’operazione di post su un semaforo:",
    "opzioni": [
      "Incrementa il valore del semaforo di 1",
      "La post opera solo nell'ambito dei mutex",
      "Decrementa il valore del semaforo di 1"
    ],
    "soluzioni": [
      "Incrementa il valore del semaforo di 1"
    ]
  },
  {
    "domanda": "Convenzionalmente, l'indice 0 (zero) dell'array di un file descriptor identifica:",
    "opzioni": [
      "Lo \"standard input\"",
      "Lo \"standard output\"",
      "Lo \"standard error\""
    ],
    "soluzioni": [
      "Lo \"standard input\""
    ]
  },
  {
    "domanda": "Dire se la seguente affermazione è corretta: \"Il secondo argomento da passare alla funzione pthread_mutex_init è un puntatore ad un oggetto mutex_attribute, che specifica gli attributi del mutex\"",
    "opzioni": [
      "Sì, è corretta",
      "Solo l'ultima parte è corretta",
      "No, non è corretta"
    ],
    "soluzioni": [
      "Sì, è corretta"
    ]
  },
  {
    "domanda": "Molti user-level threads possono essere mappati su un singolo kernel thread",
    "opzioni": [
      "Solo con sistemi operativi che supportano i kernel threads",
      "Falso",
      "Vero"
    ],
    "soluzioni": [
      "Vero"
    ]
  },
  {
    "domanda": "In GDB, per eliminare un breakpoint precedentemente specificato, occorre:",
    "opzioni": [
      "Non è possibile eliminare un breakpoint manualmente, vengono eliminati da GDB automaticamente al termine del processo di debug",
      "Si usa il comando \"delete\" seguito dal numero corrispondente al breakpoint che vogliamo eliminare",
      "Si usa il comando \"remove\" seguito dal nome del breakpoint che vogliamo eliminare"
    ],
    "soluzioni": [
      "Si usa il comando \"delete\" seguito dal numero corrispondente al breakpoint che vogliamo eliminare"
    ]
  }


  
]