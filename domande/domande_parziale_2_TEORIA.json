[
  {
    "domanda": "La FAT",
    "opzioni": [
      "Occupa una quantità di memoria che non varia al variare del numero di blocchi liberi",
      "E' una variante della allocazione indicizzata",
      "Ha un elemento per ogni blocco del disco e ciascun elemento contiene la dimensione e la posizione del blocco",
      "Ha un elemento per ogni blocco del disco ed è indicizzata dal numero del blocco",
      "E acronimo di File Allocation Table",
      "Raggruppa nel disco i puntatori ai vari blocchi del file"
    ],
    "soluzioni": [
      "Ha un elemento per ogni blocco del disco ed è indicizzata dal numero del blocco",
      "Occupa una quantità di memoria che non varia al variare del numero di blocchi liberi",
      "E acronimo di File Allocation Table"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Nel caso della gestione della memoria con segmentazione, con s e d si indicano, rispettivamente:",
    "opzioni": [
      "Size del segmento e displacement del segmento",
      "Size del segmento e numero del segmento",
      "Numero del segmento e dimensione del segmento",
      "Size del segmento e displacement dell'indirizzo",
      "Numero del segmento e indirizzo del dato all'interno del segmento"
    ],
    "soluzioni": [
      "Numero del segmento e indirizzo del dato all'interno del segmento"
    ],
    "tipologia": "singola"
  },
  {
    "domanda": "Il problema produttore consumatore affrontato con la memoria condivisa richiede l'utilizzo di un buffer:",
    "opzioni": [
      "Limitato, il consumatore dovrà attendere in caso di buffer vuoto",
      "Illimitato, il produttore non potrà inserire nuovi oggetti finche l'ultimo non è stato consumato",
      "Limitato, il produttore dovrà attendere in caso di buffer pieno",
      "Limitato, il produttore dovrà attendere in caso di buffer vuoto",
      "Sempre illimitato, in modo che il consumatore non deve mai attendere nuovi oggetti",
      "Limitato, lo scambio avviene sempre tramite utilizzo di semafori spinlock"
    ],
    "soluzioni": [
      "Limitato, il consumatore dovrà attendere in caso di buffer vuoto",
      "Limitato, il produttore dovrà attendere in caso di buffer pieno"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Relativamente alla formulazione generale del problema e alla soluzione al problema della sezione critica, è vero che:",
    "opzioni": [
      "Prevede che la sezione non critica sia seguita da una sezione di uscita",
      "Un requisito è che nessun processo dovrebbe attendere un tempo arbitrariamente lungo prima di uscire dalla sezione critica",
      "Prevede che la sezione critica sia preceduta da una sezione di ingresso e seguita da una sezione di uscita",
      "Uno dei requisiti è che nessun processo in esecuzione al di fuori della sua sezione critica puo' bloccare altri processi",
      "Uno dei requisiti è che due processi non possono essere mai contemporaneamente nelle loro sezioni critiche"
    ],
    "soluzioni": [
      "Uno dei requisiti è che due processi non possono essere mai contemporaneamente nelle loro sezioni critiche",
      "Uno dei requisiti è che nessun processo in esecuzione al di fuori della sua sezione critica puo' bloccare altri processi",
      "Prevede che la sezione critica sia preceduta da una sezione di ingresso e seguita da una sezione di uscita"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Nel caso di paginazione con utilizzo della TLB, con alpha=0,5, Tmem=500 ns e epsilon=10 ns:",
    "opzioni": [],
    "soluzioni": [
      "760,00"
    ],
    "tipologia": "aperta"
  },
  {
    "domanda": "Relativamente alla primitiva Test and Set Lock (TSL), secondo quanto visto nel materiale del corso, è vero che:",
    "opzioni": [
      "E' una primitiva hardware/ software di supporto alla gestione della sincronizzazione",
      "Non si può scrivere sullo stesso registro della TSL con una istruzione normale di write",
      "Non si può utilizzare per implementare un mutex",
      "E' una istruzione che legge il contenuto di un registro dedicato e scrive un valore non nullo",
      "Permette di controllare e modificare il contenuto di una parola di memoria dedicata in maniera atomica"
    ],
    "soluzioni": [
      "Permette di controllare e modificare il contenuto di una parola di memoria dedicata in maniera atomica",
      "E' una istruzione che legge il contenuto di un registro dedicato e scrive un valore non nullo"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Relativamente alla Tabella delle Pagine Invertita",
    "opzioni": [
      "Consente di ridurre la memoria dedicata alla associazione fra numero di pagina e numero di frame che la contiene rispetto alla tabella delle pagine standard",
      "È indicizzata implicitamente per numero di pagina",
      "Contiene in ogni sua riga il numero del frame",
      "Contiene una riga per ogni frame del sistema",
      "Non richiede che venga letto il contenuto di più righe per ottenere il numero di frame che serve",
      "E' indicizzata utilizzando il numero di frame e si cerca il numero di pagina in ogni sua riga in modo da ottenere l'offset"
    ],
    "soluzioni": [
      "Consente di ridurre la memoria dedicata alla associazione fra numero di pagina e numero di frame che la contiene rispetto alla tabella delle pagine standard",
      "Contiene una riga per ogni frame del sistema"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Relativamente al fenomeno del trashing",
    "opzioni": [
      "La percentuale di pagine che viene utilizzata solo in lettura non è correlata",
      "L'efficienza complessiva del sistema di memoria di secondo livello è correlata",
      "Si può gestire anche ignorando il parametro delta = numero di riferimenti",
      "Il numero di processi attivi nel sistema non è correlato",
      "Per risolverlo può essere sufficiente contare il page fault rate e agire di conseguenza"
    ],
    "soluzioni": [
      "Per risolverlo può essere sufficiente contare il page fault rate e agire di conseguenza",
      "L'efficienza complessiva del sistema di memoria di secondo livello è correlata",
      "Si può gestire anche ignorando il parametro delta = numero di riferimenti"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Considerando il working set model e il suo utilizzo per la allocazione delle pagine ai processi, quale è l'effetto dell'incremento del valore di delta",
    "opzioni": [
      "Il numero di pagine allocate per un processo tende a decrescere",
      "Il page fault rate tende a crescere",
      "Il numero di pagine allocate per un processo tende a crescere",
      "Il page fault rate rimane invariato",
      "Il context switch overhead tende a crescere",
      "Il page fault rate tende a decrescere"
    ],
    "soluzioni": [
      "Il page fault rate tende a decrescere",
      "Il numero di pagine allocate per un processo tende a crescere"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Un sistema di elaborazione ha 64 Megabyte di memoria fisica di primo livello, l'indirizzamento è su 26 bit, e la dimensione di una riga della tabella delle pagine è di 14 bit. Quale è il numero di bit del displacement (o offset) che rappresenta una parte dell'indirizzo logico.",
    "opzioni": [],
    "soluzioni": [
      "12,00"
    ],
    "tipologia": "aperta"
  },
  {
    "domanda": "Relativamente allo schema a blocchi rappresentativo della segmentazione descritto nel seguito, sono vere le seguenti affermazioni:",
    "opzioni": [
      "N= indica la routine di interrupt che viene lanciata al termine della istruzione che ha provocato l'accesso illegale in memoria",
      "E = Numero del segmento",
      "F = test avvenuto con successo",
      "C = test di uguaglianza fra numero di segmento indirizzato e numero presente nella tabella dei segmenti",
      "M = Tabella dei segmenti",
      "A = numero della pagina",
      "G = Test fallito",
      "L = limite",
      "I = base indirizzo base del segmento",
      "B = Numero del segmento",
      "H = Memoria di primo livello",
      "D = somma il displacement con il numero di segmento per formare indirizzo completo"
    ],
    "soluzioni": [
      "E = Numero del segmento",
      "F = test avvenuto con successo",
      "G = Test fallito",
      "H = Memoria di primo livello",
      "M = Tabella dei segmenti"
    ],
    "tipologia": "multiple",
    "img": "lab_013.png"
  },
  {
    "domanda": "Relativamente al codice (parzialmente offuscato) dell'algoritmo del banchiere visto nel materiale del corso e descritto nel seguito, è vero che:",
    "opzioni": [
      "Matrice Disponibili = identifica le istanze disponibili di ciascuna risorsa",
      "Vettore Lavoro = identifica il numero di risorse accumulate e rese disponibili dai processi man mano che si procede con le iterazioni e si simula terminazione di ciascuno di essi",
      "riga xxx A xxx = Scansiona i processi da 1 sino an",
      "Necessità matrice che indica la necessità di risorse residue di ciascun tipo per ciascun processo",
      "Vettore Assegnate = identifica il numero di risorse di ciascun tipo assegnate a ciascun processo"
    ],
    "soluzioni": [
      "Vettore Lavoro = identifica il numero di risorse accumulate e rese disponibili dai processi man mano che si procede con le iterazioni e si simula terminazione di ciascuno di essi",
      "Necessità matrice che indica la necessità di risorse residue di ciascun tipo per ciascun processo"
    ],
    "tipologia": "multiple",
    "img": "lab_014.png"
  },
  {
    "domanda": "Si supponga di avere un processo caratterizzato da un codice di 234 Kbyte, un'area dati di 258 Kbyte e uno stack di 66 Kbyte. Si consideri che diversi segmenti non possono condividere la stessa pagina. Si ipotizzi che la macchina fisica possa avere 128 Megabyte di memoria massima teorica, che l'indirizzamento logico sia su 22 bit, e che il processo sia tutto in memoria durante l'esecuzione. La memoria è organizzata a pagine, con pagine di 8 Kbyte. Quante sono le righe valide della tabella delle pagine del processo?",
    "opzioni": [],
    "soluzioni": [
      "72"
    ],
    "tipologia": "aperta"
  },
  {
    "domanda": "Per la prevenzione degli stalli:",
    "opzioni": [
      "Si può sempre applicare la impossibilità di prelazione per qualunque tipo di risorsa",
      "Si possono usare, fra gli altri, l'algoritmo di Peterson, l'algoritmo del Banchiere, il grafo di allocazione delle risorse",
      "In caso di risorse sempre condivisibili si può utilizzare la mutua esclusione",
      "Si può impedire che un processo richieda una risorsa se ne possiede già altre",
      "Si può impedire che un processo richieda risorse agli altri processi a meno che non si verifichino specifiche condizioni tali per cui l'attesa circolare viene esclusa"
    ],
    "soluzioni": [
      "Si può impedire che un processo richieda risorse agli altri processi a meno che non si verifichino specifiche condizioni tali per cui l'attesa circolare viene esclusa",
      "Si può impedire che un processo richieda una risorsa se ne possiede già altre",
      "In caso di risorse sempre condivisibili si può utilizzare la mutua esclusione"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "L'architettura di un calcolatore ha 8 Megabyte di memoria massima di primo livello, l'indirizzamento è su 26 bit, e la dimensione di una riga della tabella delle pagine è di 15 bit. Quale è la dimensione in byte di una pagina",
    "opzioni": [],
    "soluzioni": [
      "256,00"
    ],
    "tipologia": "aperta"
  },
  {
    "domanda": "In caso di implementazione del paradigma Produttore Consumatore che preveda lo sfruttamento completo di un buffer in memoria condivisa, è vero che:",
    "opzioni": [
      "Non si verifica una corsa critica perché questa implementazione previene intrinsecamente il verificarsi di corse critiche",
      "Si può verificare una corsa critica perché le istruzioni di aggiornamento della variabile counter non sono implementate in maniera atomica",
      "Si verifica sistematicamente una corsa critica perché le istruzioni di aggiornamento della variabile counter non sono implementate in maniera atomica",
      "Si può verificare una corsa critica legata al fatti che l'ISA assembly che a basso livello traduce l'implementazione scritta in C è di tipo load store",
      "Si può verificare una corsa critica che porti a valori erronei della variabile counter perché l'interrupt che provoca il context switch si verifica durante l'esecuzione di una istruzione assembly"
    ],
    "soluzioni": [
      "Si può verificare una corsa critica perché le istruzioni di aggiornamento della variabile counter non sono implementate in maniera atomica",
      "Si può verificare una corsa critica legata al fatti che l'ISA assembly che a basso livello traduce l'implementazione scritta in C è di tipo load store"
    ],
    "tipologia": "multiple",
    "img": "lab_015.png"
  },
  {
    "domanda": "Per la gestione dei blocchi liberi del filesystem",
    "opzioni": [
      "Utilizzando una bitmap si ottimizza il caso di disco molto pieno rispetto all'uso dell'allocazione indicizzata",
      "Quando si usa la bitmap è utile una ISA che preveda istruzioni di salto basate su singolo bit",
      "Si può usare una bitmap",
      "Si può usare l'allocazione indicizzata insieme a una bitmap",
      "Utilizzando l'allocazione indicizzata si ottimizza il caso di disco vuoto rispetto all'uso di una bitmap"
    ],
    "soluzioni": [
      "Si può usare una bitmap",
      "Quando si usa la bitmap è utile una ISA che preveda istruzioni di salto basate su singolo bit"
    ],
    "tipologia": "multiple"
  },
  

  {
    "domanda": "Per la gestione dei blocchi liberi del filesystem",
    "opzioni": [
      "Utilizzando una bitmap si ottimizza il caso di disco molto pieno rispetto all'uso dell'allocazione indicizzata",
      "Quando si usa la bitmap è utile una ISA che preveda istruzioni di salto basate su singolo bit",
      "Si usa sempre una bitmap",
      "Si può usare l'allocazione indicizzata insieme a una bitmap",
      "Utilizzando l'allocazione indicizzata si ottimizza il caso di disco pieno rispetto all'uso di una bitmap"
    ],
    "soluzioni": [
      "Quando si usa la bitmap è utile una ISA che preveda istruzioni di salto basate su singolo bit",
      "Utilizzando l'allocazione indicizzata si ottimizza il caso di disco pieno rispetto all'uso di una bitmap"
    ],
    "tipologia": "multiple"
  },


  {
    "domanda": "Il page fault si può verificare quando:",
    "opzioni": [
      "Viene settato il bit di modifica che certifica un accesso in scrittura a una pagina",
      "Viene indirizzata una pagina non presente in memoria principale",
      "Non vi sono più pagine disponibili da allocare per il processo in esecuzione",
      "Viene indirizzata una pagina non presente nel segmento principale del processo",
      "Viene indirizzata una pagina non presente in TLB"
    ],
    "soluzioni": [
      "Viene indirizzata una pagina non presente in memoria principale"
    ],
    "tipologia": "singola"
  },
  {
    "domanda": "Relativamente alla implementazione del semaforo NON Busy waiting, è vero che:",
    "opzioni": [
      "Entrambe le primitive devono essere non interrompibili",
      "E' previsto l'utilizzo di una lista solo nella implementazione della primitiva wait",
      "La wait è implementata utilizzando la primitiva hardware TSL",
      "La signal è implementata dal codice seguente: S=S+1;",
      "La chiamata della wait prevede che un processo vada tutte le volte nello stato waiting, mentre la chiamata della signal prevede che il processo vada nello stato ready"
    ],
    "soluzioni": [
      "Entrambe le primitive devono essere non interrompibili"
    ],
    "tipologia": "singola"
  },
  {
    "domanda": "Relativamente all'algoritmo di Peterson, è vero che:",
    "opzioni": [
      "Rappresenta una delle soluzioni al problema della sezione critica in caso di due o più processi",
      "Nel suo codice viene utilizzato un vettore di booleani condiviso fra tutti i processi coinvolti",
      "Per ingresso nella sezione critica viene verificato che il processo abbia una priorità superiore all'altro processo",
      "All'uscita dalla sezione critica lo scalare viene settato a false",
      "Nel suo codice viene utilizzato un intero condiviso fra tutti i processi coinvolti"
    ],
    "soluzioni": [
      "Nel suo codice viene utilizzato un vettore di booleani condiviso fra tutti i processi coinvolti",
      "Nel suo codice viene utilizzato un intero condiviso fra tutti i processi coinvolti"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Si consideri un sistema che usa la memoria virtuale (paginazione on demand) con utilizzo della CPU al 25%, periferiche al 7% e HW di paginazione al 92%. Sono vere le seguenti affermazioni:",
    "opzioni": [
      "Decrementare la dimensione delle pagine non incrementa in nessun caso la % di occupazione della CPU",
      "Installare una CPU più lenta può incrementare la % di occupazione della CPU",
      "Incrementare la dimensione delle pagine non incrementa in nessun caso la % di occupazione della CPU",
      "Incrementare il livello di multiprogrammazione può incrementare la % di occupazione della CPU",
      "Installare una memoria di primo livello di maggiori dimensioni può incrementare la % di occupazione della CPU"
    ],
    "soluzioni": [
      "Installare una CPU più lenta può incrementare la % di occupazione della CPU",
      "Installare una memoria di primo livello di maggiori dimensioni può incrementare la % di occupazione della CPU"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Relativamente allo schema a blocchi rappresentativo della paginazione descritto nel seguito, sono vere le seguenti affermazioni:",
    "opzioni": [
      "H=p= numero di pagina",
      "G= Memoria Principale",
      "D= Tabella delle pagine che risiede su supporto di memoria dedicato",
      "I=d= scostamento di pagina",
      "F=f= numero del frame",
      "A= indirizzo fisico",
      "E= Indirizzo Logico",
      "B=p= numero di pagina",
      "M=d= dimensione del segmento",
      "L=f= numero del segmento",
      "c=f= frame che ha dimensione uguale a quella della pagina"
    ],
    "soluzioni": [
      "B=p= numero di pagina",
      "F=f= numero del frame",
      "G= Memoria Principale",
      "H=p= numero di pagina",
      "I=d= scostamento di pagina"
    ],
    "tipologia": "multiple",
    "img": "lab_016.png"
  },
  {
    "domanda": "Relativamente allo schema a blocchi rappresentativo della TLB descritto nel seguito, sono vere le seguenti affermazioni:",
    "opzioni": [
      "A= numero di pagina",
      "F= numero di frame",
      "M= numero di pagina",
      "G=f= Numero di pagina",
      "I= Memoria Secondaria",
      "C= TLB Miss",
      "N=f= numero di frame",
      "L=d= displacement",
      "H=d= scostamento di pagina",
      "E= Tabella delle pagine che risiede su supporto di memoria dedicato",
      "D= Numero di pagina",
      "B= TLB Hit"
    ],
    "soluzioni": [
      "A= numero di pagina",
      "B= TLB Hit",
      "C= TLB Miss",
      "F= numero di frame",
      "H=d= scostamento di pagina",
      "L=d= displacement",
      "M= numero di pagina"
    ],
    "tipologia": "multiple",
    "img": "lab_017.png"
  },
  {
    "domanda": "Quali soluzioni per la protezione degli spazi di memoria da parte del kernel sono efficaci per almeno una delle tecniche di allocazione viste durante il corso (contigua, segmentata, paginata)",
    "opzioni": [
      "Utilizzo del PTLR",
      "Utilizzo della tabella dei segmenti e del test HW",
      "Utilizzo di 2 registri che definiscano i confini dello spazio di memoria allocato al processo da usare per un test HW",
      "Utilizzo di un timer da inizializzare prima di avviare il task utente di cui controllare l'accesso",
      "Utilizzo della tabella delle pagine e del dei bit di validità",
      "Utilizzo del registro di scorrimento per contare gli accessi",
      "Utilizzo della TLB invertita"
    ],
    "soluzioni": [
      "Utilizzo della tabella dei segmenti e del test HW",
      "Utilizzo del PTLR",
      "Utilizzo della tabella delle pagine e del dei bit di validità",
      "Utilizzo di 2 registri che definiscano i confini dello spazio di memoria allocato al processo da usare per un test HW"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Un sistema di elaborazione ha 512 Megabyte di memoria fisica di primo livello, l'indirizzamento è su 26 bit, e la dimensione di una riga della tabella delle pagine è di 14 bit. Quale è il numero di bit del displacement (o offset) che rappresenta una parte dell'indirizzo logico.",
    "opzioni": [],
    "soluzioni": [
      "15,00"
    ],
    "tipologia": "aperta"
  },
  {
    "domanda": "Nel caso di paginazione con utilizzo della TLB, con alpha = 0,5, Tmem = 300 ns e epsilon = 30 ns:",
    "opzioni": [],
    "soluzioni": [
      "480,00"
    ],
    "tipologia": "aperta"
  },
  {
    "domanda": "Relativamente al seguente codice che permette la comunicazione fra thread a livello utente (Produttore/Consumatore):",
    "opzioni": [
      "Il produttore cicla indefinitamente in caso di buffer completamente pieno",
      "La variabile condivisa preleva indica l'elemento del buffer su cui scrivere",
      "La variabile condivisa inserisci indica l'elemento del buffer su cui leggere",
      "Il codice non è soggetto a corse critiche",
      "Il consumatore cicla indefinitamente in caso di buffer completamente vuoto"
    ],
    "soluzioni": [
      "Il consumatore cicla indefinitamente in caso di buffer completamente vuoto",
      "Il codice non è soggetto a corse critiche"
    ],
    "tipologia": "multiple",
    "img": "lab_022.png"
  },
  {
    "domanda": "Quale delle seguenti affermazioni fa parte della definizione di stato sicuro secondo quanto visto a lezione e sul libro di testo",
    "opzioni": [
      "Per ogni sequenza di processi P1...Pn, le risorse di Pi devono soddisfare le richieste di un Pj con j>i, Pj deve eventualmente attendere che i Pi finiscano",
      "Deve esistere almeno una sequenza di processi P1...Pn tale che per ogni Pi, le sue richieste sono soddisfatte con le risorse disponibili più quelle possedute da Pj con j<i, Pi deve eventualmente attendere che i Pj finiscano",
      "Per ogni sequenza di processi P1...Pn, le risorse di Pi devono soddisfare le richieste di Pj con j<i. Pi deve eventualmente attendere che i Pj finiscano",
      "Deve esistere una ed una sola sequenza di processi P1...Pn tale che per ogni Pi, le sue richieste sono soddisfatte con le risorse disponibili più quelle di Pj con j<i. Pi deve eventualmente attendere che i Pj finiscano",
      "Deve esistere almeno una sequenza di processi P1...Pn tale per cui le risorse richieste da Pi non devono coincidere con le risorse possedute da Pj con j<i. Pi deve eventualmente attendere che i Pj finiscano"
    ],
    "soluzioni": [
      "Deve esistere almeno una sequenza di processi P1...Pn tale che per ogni Pi, le sue richieste sono soddisfatte con le risorse disponibili più quelle possedute da Pj con j<i, Pi deve eventualmente attendere che i Pj finiscano"
    ],
    "tipologia": "singola"
  },
  {
    "domanda": "Nel caso di paginazione con utilizzo della TLB, con alpha = 0,5, Tmem = 200 ns e epsilon = 20 ns:",
    "opzioni": [],
    "soluzioni": [
      "320,00"
    ],
    "tipologia": "aperta"
  },
  {
    "domanda": "I semafori con busy waiting (spinlock), quando attivati per un processo",
    "opzioni": [
      "Non mandano il processo fra i processi waiting",
      "A livello di implementazione prevedono l'utilizzo di un loop in ciascuna delle primitive",
      "Non tengono occupata la cpu ciclando a vuoto",
      "Se implementati con una libreria utente, devono necessariamente richiamare una system call",
      "Sono meno problematici sui sistemi multiprocessore"
    ],
    "soluzioni": [
      "Non mandano il processo fra i processi waiting",
      "Sono meno problematici sui sistemi multiprocessore"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Si supponga di avere un processo caratterizzato da un codice di 234 Kbyte, un'area dati di 258 Kbyte e uno stack di 42 Kbyte. Si consideri che diversi segmenti non possono condividere la stessa pagina. Si ipotizzi che la macchina fisica possa avere 128 Megabyte di memoria massima teorica, che l'indirizzamento logico sia su 22 bit, e che il processo sia tutto in memoria durante l'esecuzione. La memoria è organizzata a pagine, con pagine di 8 Kbyte. Quante sono le righe valide della tabella delle pagine del processo?",
    "opzioni": [],
    "soluzioni": [
      "69"
    ],
    "tipologia": "aperta"
  },
  {
    "domanda": "Si supponga di avere un processo caratterizzato da un codice di 234 Kbyte, un'area dati di 258 Kbyte e uno stack di 89 Kbyte. Si consideri che diversi segmenti non possono condividere la stessa pagina. Si ipotizzi che la macchina fisica possa avere 128 Megabyte di memoria massima teorica, che l'indirizzamento logico sia su 22 bit, e che il processo sia tutto in memoria durante l'esecuzione. La memoria è organizzata a pagine, con pagine di 8 Kbyte. Quante sono le righe valide della tabella delle pagine del processo?",
    "opzioni": [],
    "soluzioni": [
      "75"
    ],
    "tipologia": "aperta"
  },
  {
    "domanda": "Seleziona unicamente i livelli del modello OSI che hanno una corrispondenza diretta con livelli dello stack TCP/IP:",
    "opzioni": [
      "Livello di presentazione",
      "Livello di sessione",
      "Livello di rete",
      "Livello di trasporto"
    ],
    "soluzioni": [
      "Livello di trasporto",
      "Livello di rete"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Quali di queste condizioni sono necessarie ma non sufficienti per lo stallo",
    "opzioni": [
      "Possesso e attesa",
      "Attesa Circolare",
      "Impossibilità di prelazione",
      "Ordinamento delle richieste e delle risorse in modo che ogni processo possa richiedere le risorse in ordine crescente di numerazione",
      "Presenza di più cicli nel grafo di allocazione delle risorse",
      "Mutua esclusione",
      "Presenza di un ciclo nel grafo di allocazione delle risorse con solo istanza singole",
      "Assenza di cicli nel grafo di allocazione delle risorse"
    ],
    "soluzioni": [
      "Mutua esclusione",
      "Attesa Circolare",
      "Possesso e attesa",
      "Impossibilità di prelazione",
      "Presenza di più cicli nel grafo di allocazione delle risorse"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Seleziona, tra le seguenti, le primitive socket di Berkley corrette:",
    "opzioni": [
      "bind()",
      "create()",
      "set()",
      "close()"
    ],
    "soluzioni": [
      "bind()",
      "close()"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Relativamente al grafo di allocazione delle risorse, è vero che:",
    "opzioni": [
      "Una risorsa ha sempre una istanza",
      "un ciclo nel grafo di allocazione delle risorse implica la presenza di un deadlock",
      "Un arco orientato che va da una risorsa a un processo indica che la risorsa è stata allocata per un processo",
      "Un arco che va da un processo a una risorsa indica che il processo ha richiesto la risorsa ed è in attesa",
      "I vertici del grafo rappresentano i processi, gli archi non orientati rappresentano le risorse"
    ],
    "soluzioni": [
      "Un arco che va da un processo a una risorsa indica che il processo ha richiesto la risorsa ed è in attesa",
      "Un arco orientato che va da una risorsa a un processo indica che la risorsa è stata allocata per un processo"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "I socket di tipo stream (o connection):",
    "opzioni": [
      "permettono di instaurare un canale logico di comunicazione tra mittente e destinario",
      "costituiscono primitive di livello 2 del modello OSI",
      "non garantiscono l'ordine di consegna dei messaggi",
      "sono implementati dal protocollo UDP"
    ],
    "soluzioni": [
      "permettono di instaurare un canale logico di comunicazione tra mittente e destinario"
    ],
    "tipologia": "singola"
  },
  {
    "domanda": "Si supponga di avere un processo caratterizzato da un codice di 234 Kbyte, un'area dati di 258 Kbyte e uno stack di 33 Kbyte. Si consideri che diversi segmenti non possono condividere la stessa pagina. Si ipotizzi che la macchina fisica possa avere 128 Megabyte di memoria massima teorica, che l'indirizzamento logico sia su 22 bit, e che il processo sia tutto in memoria durante l'esecuzione. La memoria è organizzata a pagine, con pagine di 8 Kbyte. Quante sono le righe valide della tabella delle pagine del processo?",
    "opzioni": [],
    "soluzioni": [
      "68"
    ],
    "tipologia": "aperta"
  },
  {
    "domanda": "Nel caso di paginazione con utilizzo della TLB, con alpha=0,5, Tmem = 400 ns e epsilon=20 ns:",
    "opzioni": [],
    "soluzioni": [
      "620,00"
    ],
    "tipologia": "aperta"
  },
  {
    "domanda": "Un sistema di elaborazione ha 128 Megabyte di memoria fisica di primo livello, l'indirizzamento è su 26 bit, e la dimensione di una riga della tabella delle pagine è di 14 bit. Quale è il numero di bit del displacement (o offset) che rappresenta una parte dell'indirizzo logico.",
    "opzioni": [],
    "soluzioni": [
      "13,00"
    ],
    "tipologia": "aperta"
  }
]