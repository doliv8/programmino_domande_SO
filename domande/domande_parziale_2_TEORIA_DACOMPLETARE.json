[
  {
    "domanda": "La FAT",
    "opzioni": [
      "Occupa una quantità di memoria che non varia al variare del numero di blocchi liberi",
      "E' una variante della allocazione indicizzata",
      "Ha un elemento per ogni blocco del disco e ciascun elemento contiene la dimensione e la posizione del blocco",
      "Ha un elemento per ogni blocco del disco ed è indicizzata dal numero del blocco",
      "E acronimo di File Aggregation Table",
      "Raggruppa nel disco i puntatori ai vari blocchi del file"
    ],
    "soluzioni": [
      "Ha un elemento per ogni blocco del disco ed è indicizzata dal numero del blocco",
      "Occupa una quantità di memoria che non varia al variare del numero di blocchi liberi"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Nel caso della gestione della memoria con segmentazione, con s e d si indicano, rispettivamente:",
    "opzioni": [
      "Size del segmento e displacement del segmento",
      "Size del segmento e numero del segmento",
      "Numero del segmento e dimensione del segmento",
      "Size del segmento e displacement dell'indirizzo",
      "Numero del segmento e indirizzo del dato all'interno del segmento"
    ],
    "soluzioni": [
      "Numero del segmento e indirizzo del dato all'interno del segmento"
    ],
    "tipologia": "singola"
  },
  {
    "domanda": "Il problema produttore consumatore affrontato con la memoria condivisa richiede l'utilizzo di un buffer:",
    "opzioni": [
      "Limitato, il consumatore dovrà attendere in caso di buffer vuoto",
      "Illimitato, il produttore non potrà inserire nuovi oggetti finche l'ultimo non è stato consumato",
      "Limitato, il produttore dovrà attendere in caso di buffer pieno",
      "Limitato, il produttore dovrà attendere in caso di buffer vuoto",
      "Sempre illimitato, in modo che il consumatore non deve mai attendere nuovi oggetti",
      "Limitato, lo scambio avviene sempre tramite utilizzo di semafori spinlock"
    ],
    "soluzioni": [
      "Limitato, il consumatore dovrà attendere in caso di buffer vuoto",
      "Limitato, il produttore dovrà attendere in caso di buffer pieno"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Relativamente alla formulazione generale del problema e alla soluzione al problema della sezione critica, è vero che:",
    "opzioni": [
      "Prevede che la sezione non critica sia seguita da una sezione di uscita",
      "Un requisito è che nessun processo dovrebbe attendere un tempo arbitrariamente lungo prima di uscire dalla sezione critica",
      "Prevede che la sezione critica sia preceduta da una sezione di ingresso e seguita da una sezione di uscita",
      "Uno dei requisiti è che nessun processo in esecuzione al di fuori della sua sezione critica puo' bloccare altri processi",
      "Uno dei requisiti è che due processi non possono essere mai contemporaneamente nelle loro sezioni critiche"
    ],
    "soluzioni": [
      "Uno dei requisiti è che due processi non possono essere mai contemporaneamente nelle loro sezioni critiche",
      "Uno dei requisiti è che nessun processo in esecuzione al di fuori della sua sezione critica puo' bloccare altri processi",
      "Prevede che la sezione critica sia preceduta da una sezione di ingresso e seguita da una sezione di uscita"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Nel caso di paginazione con utilizzo della TLB, con alpha=0,5, Tmem=500 ns e epsilon=10 ns:",
    "opzioni": [],
    "soluzioni": [
      "760,00"
    ],
    "tipologia": "aperta"
  },
  {
    "domanda": "Relativamente alla primitiva Test and Set Lock (TSL), secondo quanto visto nel materiale del corso, è vero che:",
    "opzioni": [
      "E' una primitiva hardware/ software di supporto alla gestione della sincronizzazione",
      "Non si può scrivere sullo stesso registro della TSL con una istruzione normale di write",
      "Non si può utilizzare per implementare un mutex",
      "E' una istruzione che legge il contenuto di un registro dedicato e scrive un valore non nullo",
      "Permette di controllare e modificare il contenuto di una parola di memoria dedicata in maniera atomica"
    ],
    "soluzioni": [
      "Permette di controllare e modificare il contenuto di una parola di memoria dedicata in maniera atomica",
      "E una istruzione che legge il contenuto di un registro dedicato e scrive un valore non nullo"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Relativamente alla Tabella delle Pagine Invertita",
    "opzioni": [
      "Consente di ridurre la memoria dedicata alla associazione fra numero di pagina e numero di frame che la contiene rispetto alla tabella delle pagine standard",
      "È indicizzata implicitamente per numero di pagina",
      "Contiene in ogni sua riga il numero del frame",
      "Contiene una riga per ogni frame del sistema",
      "Non richiede che venga letto il contenuto di più righe per ottenere il numero di frame che serve",
      "E' indicizzata utilizzando il numero di frame e si cerca il numero di pagina in ogni sua riga in modo da ottenere l'offset"
    ],
    "soluzioni": [
      "Consente di ridurre la memoria dedicata alla associazione fra numero di pagina e numero di frame che la contiene rispetto alla tabella delle pagine standard",
      "Contiene una riga per ogni frame del sistema"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Relativamente al fenomeno del trashing",
    "opzioni": [
      "La percentuale di pagine che viene utilizzata solo in lettura non è correlata",
      "L'efficienza complessiva del sistema di memoria di secondo livello è correlata",
      "Si può gestire anche ignorando il parametro delta = numero di riferimenti",
      "Il numero di processi attivi nel sistema non è correlato",
      "Per risolverlo può essere sufficiente contare il page fault rate e agire di conseguenza"
    ],
    "soluzioni": [
      "Per risolverlo può essere sufficiente contare il page fault rate e agire di conseguenza",
      "L'efficienza complessiva del sistema di memoria di secondo livello è correlata",
      "Si può gestire anche ignorando il parametro delta = numero di riferimenti"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Considerando il working set model e il suo utilizzo per la allocazione delle pagine ai processi, quale è l'effetto dell'incremento del valore di delta",
    "opzioni": [
      "Il numero di pagine allocate per un processo tende a decrescere",
      "Il page fault rate tende a crescere",
      "Il numero di pagine allocate per un processo tende a crescere",
      "Il page fault rate rimane invariato",
      "Il context switch overhead tende a crescere",
      "Il page fault rate tende a decrescere"
    ],
    "soluzioni": [
      "Il page fault rate tende a decrescere",
      "Il numero di pagine allocate per un processo tende a crescere"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Un sistema di elaborazione ha 64 Megabyte di memoria fisica di primo livello, l'indirizzamento è su 26 bit, e la dimensione di una riga della tabella delle pagine è di 14 bit. Quale è il numero di bit del displacement (o offset) che rappresenta una parte dell'indirizzo logico.",
    "opzioni": [],
    "soluzioni": [
      "12,00"
    ],
    "tipologia": "aperta"
  },
  {
    "domanda": "Relativamente allo schema a blocchi rappresentativo della segmentazione descritto nel seguito, sono vere le seguenti affermazioni:",
    "opzioni": [
      "N= indica la routine di interrupt che viene lanciata al termine della istruzione che ha provocato l'accesso illegale in memoria",
      "E = Numero del segmento",
      "F = test avvenuto con successo",
      "C = test di uguaglianza fra numero di segmento indirizzato e numero presente nella tabella dei segmenti",
      "M = Tabella dei segmenti",
      "A = numero della pagina",
      "G = Test fallito",
      "L = limite",
      "I = base indirizzo base del segmento",
      "B = Numero del segmento",
      "H = Memoria di primo livello",
      "D = somma il displacement con il numero di segmento per formare indirizzo completo"
    ],
    "soluzioni": [
      "E = Numero del segmento",
      "F = test avvenuto con successo",
      "G = Test fallito",
      "H = Memoria di primo livello",
      "M = Tabella dei segmenti"
    ],
    "tipologia": "multiple",
    "img": "lab_013.png"
  },
  {
    "domanda": "Relativamente al codice (parzialmente offuscato) dell'algoritmo del banchiere visto nel materiale del corso e descritto nel seguito, è vero che:",
    "opzioni": [
      "Matrice Disponibili = identifica le istanze disponibili di ciascuna risorsa",
      "Vettore Lavoro = identifica il numero di risorse accumulate e rese disponibili dai processi man mano che si procede con le iterazioni e si simula terminazione di ciascuno di essi",
      "riga xxx A xxx = Scansiona i processi da 1 sino an",
      "Necessità matrice che indica la necessità di risorse residue di ciascun tipo per ciascun processo",
      "Vettore Assegnate = identifica il numero di risorse di ciascun tipo assegnate a ciascun processo"
    ],
    "soluzioni": [
      "Vettore Lavoro = identifica il numero di risorse accumulate e rese disponibili dai processi man mano che si procede con le iterazioni e si simula terminazione di ciascuno di essi",
      "Necessità matrice che indica la necessità di risorse residue di ciascun tipo per ciascun processo"
    ],
    "tipologia": "multiple",
    "img": "lab_014.png"
  },





  {
    "domanda": "Si supponga di avere un processo caratterizzato da un codice di 234 Kbyte, un'area dati di 258 Kbyte e uno stack di 66 Kbyte. Si consideri che diversi segmenti non possono condividere la stessa pagina. Si ipotizzi che la macchina fisica possa avere 128 Megabyte di memoria massima teorica, che l'indirizzamento logico sia su 22 bit, e che il processo sia tutto in memoria durante l'esecuzione. La memoria è organizzata a pagine, con pagine di 8 Kbyte. Quante sono le righe valide della tabella delle pagine del processo?",
    "opzioni": [],
    "soluzioni": [
      "72"
    ],
    "tipologia": "aperta"
  },
  {
    "domanda": "Per la prevenzione degli stalli:",
    "opzioni": [
      "Si può sempre applicare la impossibilità di prelazione per qualunque tipo di risorsa",
      "Si possono usare, fra gli altri, l'algoritmo di Peterson, l'algoritmo del Banchiere, il grafo di allocazione delle risorse",
      "In caso di risorse sempre condivisibili si può utilizzare la mutua esclusione",
      "Si può impedire che un processo richieda una risorsa se ne possiede già altre",
      "Si può impedire che un processo richieda risorse agli altri processi a meno che non si verifichino specifiche condizioni tali per cui l'attesa circolare viene esclusa"
    ],
    "soluzioni": [
      "Si può impedire che un processo richieda risorse agli altri processi a meno che non si verifichino specifiche condizioni tali per cui l'attesa circolare viene esclusa",
      "Si può impedire che un processo richieda una risorsa se ne possiede già altre",
      "In caso di risorse sempre condivisibili si può utilizzare la mutua esclusione"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "L'architettura di un calcolatore ha 8 Megabyte di memoria massima di primo livello, l'indirizzamento è su 26 bit, e la dimensione di una riga della tabella delle pagine è di 15 bit. Quale è la dimensione in byte di una pagina",
    "opzioni": [],
    "soluzioni": [
      "256,00"
    ],
    "tipologia": "aperta"
  },
  {
    "domanda": "In caso di implementazione del paradigma Produttore Consumatore che preveda lo sfruttamento completo di un buffer in memoria condivisa, è vero che:",
    "opzioni": [
      "Non si verifica una corsa critica perché questa implementazione previene intrinsecamente il verificarsi di corse critiche",
      "Si può verificare una corsa critica perché le istruzioni di aggiornamento della variabile counter non sono implementate in maniera atomica",
      "Si verifica sistematicamente una corsa critica perché le istruzioni di aggiornamento della variabile counter non sono implementate in maniera atomica",
      "Si può verificare una corsa critica legata al fatti che l'ISA assembly che a basso livello traduce l'implementazione scritta in C è di tipo load store",
      "Si può verificare una corsa critica che porti a valori erronei della variabile counter perché l'interrupt che provoca il context switch si verifica durante l'esecuzione di una istruzione assembly"
    ],
    "soluzioni": [
      "Si può verificare una corsa critica perché le istruzioni di aggiornamento della variabile counter non sono implementate in maniera atomica",
      "Si può verificare una corsa critica legata al fatti che l'ISA assembly che a basso livello traduce l'implementazione scritta in C è di tipo load store"
    ],
    "tipologia": "multiple",
    "img": "lab_015.png"
  },
  {
    "domanda": "Per la gestione dei blocchi liberi del filesystem",
    "opzioni": [
      "Utilizzando una bitmap si ottimizza il caso di disco molto pieno rispetto all'uso dell'allocazione indicizzata",
      "Quando si usa la bitmap è utile una ISA che preveda istruzioni di salto basate su singolo bit",
      "Si può usare una bitmap",
      "Si può usare l'allocazione indicizzata insieme a una bitmap",
      "Utilizzando l'allocazione indicizzata si ottimizza il caso di disco vuoto rispetto all'uso di una bitmap"
    ],
    "soluzioni": [
      "Si può usare una bitmap",
      "Quando si usa la bitmap è utile una ISA che preveda istruzioni di salto basate su singolo bit"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Il page fault si può verificare quando:",
    "opzioni": [
      "Viene settato il bit di modifica che certifica un accesso in scrittura a una pagina",
      "Viene indirizzata una pagina non presente in memoria principale",
      "Non vi sono più pagine disponibili da allocare per il processo in esecuzione",
      "Viene indirizzata una pagina non presente nel segmento principale del processo",
      "Viene indirizzata una pagina non presente in TLB"
    ],
    "soluzioni": [
      "Viene indirizzata una pagina non presente in memoria principale"
    ],
    "tipologia": "singola"
  },
  {
    "domanda": "Relativamente alla implementazione del semaforo NON Busy waiting, è vero che:",
    "opzioni": [
      "Entrambe le primitive devono essere non interrompibili",
      "E' previsto l'utilizzo di una lista solo nella implementazione della primitiva wait",
      "La wait è implementata utilizzando la primitiva hardware TSL",
      "La signal è implementata dal codice seguente: S=S+1;",
      "La chiamata della wait prevede che un processo vada tutte le volte nello stato waiting, mentre la chiamata della signal prevede che il processo vada nello stato ready"
    ],
    "soluzioni": [
      "Entrambe le primitive devono essere non interrompibili"
    ],
    "tipologia": "singola"
  },
  {
    "domanda": "Relativamente all'algoritmo di Peterson, è vero che:",
    "opzioni": [
      "Rappresenta una delle soluzioni al problema della sezione critica in caso di due o più processi",
      "Nel suo codice viene utilizzato un vettore di booleani condiviso fra tutti i processi coinvolti",
      "Per ingresso nella sezione critica viene verificato che il processo abbia una priorità superiore all'altro processo",
      "All'uscita dalla sezione critica lo scalare viene settato a false",
      "Nel suo codice viene utilizzato un intero condiviso fra tutti i processi coinvolti"
    ],
    "soluzioni": [
      "Nel suo codice viene utilizzato un vettore di booleani condiviso fra tutti i processi coinvolti",
      "Nel suo codice viene utilizzato un intero condiviso fra tutti i processi coinvolti"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Si consideri un sistema che usa la memoria virtuale (paginazione on demand) con utilizzo della CPU al 25%, periferiche al 7% e HW di paginazione al 92%. Sono vere le seguenti affermazioni:",
    "opzioni": [
      "Decrementare la dimensione delle pagine non incrementa in nessun caso la % di occupazione della CPU",
      "Installare una CPU più lenta può incrementare la % di occupazione della CPU",
      "Incrementare la dimensione delle pagine non incrementa in nessun caso la % di occupazione della CPU",
      "Incrementare il livello di multiprogrammazione può incrementare la % di occupazione della CPU",
      "Installare una memoria di primo livello di maggiori dimensioni può incrementare la % di occupazione della CPU"
    ],
    "soluzioni": [
      "Installare una CPU più lenta può incrementare la % di occupazione della CPU",
      "Installare una memoria di primo livello di maggiori dimensioni può incrementare la % di occupazione della CPU"
    ],
    "tipologia": "multiple"
  },
  {
    "domanda": "Relativamente allo schema a blocchi rappresentativo della paginazione descritto nel seguito, sono vere le seguenti affermazioni:",
    "opzioni": [
      "H=p= numero di pagina",
      "G= Memoria Principale",
      "D= Tabella delle pagine che risiede su supporto di memoria dedicato",
      "I=d= scostamento di pagina",
      "F=f= numero del frame",
      "A= indirizzo fisico",
      "E= Indirizzo Logico",
      "B=p= numero di pagina",
      "M=d= dimensione del segmento",
      "L=f= del segmento",
      "c=f= frame che ha dimensione uguale a quella della pagina"
    ],
    "soluzioni": [
      "B=p= numero di pagina",
      "F=f= numero del frame",
      "G= Memoria Principale",
      "H=p= numero di pagina",
      "I=d= scostamento di pagina"
    ],
    "tipologia": "multiple",
    "img": "lab_016.png"
  },
  {
    "domanda": "Relativamente allo schema a blocchi rappresentativo della TLB descritto nel seguito, sono vere le seguenti affermazioni:",
    "opzioni": [
      "A= numero di pagina",
      "F= numero di frame",
      "M= numero di pagina",
      "G=f= Numero di pagina",
      "I= Memoria Secondaria",
      "C= TLB Miss",
      "N=f= numero di frame",
      "L=d= displacement",
      "H=d= scostamento di pagina",
      "E= Tabella delle pagine che risiede su supporto di memoria dedicato",
      "D= Numero di pagina",
      "B= TLB Hit"
    ],
    "soluzioni": [
      "A= numero di pagina",
      "B= TLB Hit",
      "C= TLB Miss",
      "F= numero di frame",
      "H=d= scostamento di pagina",
      "L=d= displacement",
      "M= numero di pagina"
    ],
    "tipologia": "multiple",
    "img": "lab_017.png"
  },
  {
    "domanda": "Quali soluzioni per la protezione degli spazi di memoria da parte del kernel sono efficaci per almeno una delle tecniche di allocazione viste durante il corso (contigua, segmentata, paginata)",
    "opzioni": [
      "Utilizzo del PTLR",
      "Utilizzo della tabella dei segmenti e del test HW",
      "Utilizzo di 2 registri che definiscano i confini dello spazio di memoria allocato al processo da usare per un test HW",
      "Utilizzo di un timer da inizializzare prima di avviare il task utente di cui controllare l'accesso",
      "Utilizzo della tabella delle pagine e del dei bit di validità",
      "Utilizzo del registro di scorrimento per contare gli accessi",
      "Utilizzo della TLB invertita"
    ],
    "soluzioni": [
      "Utilizzo della tabella dei segmenti e del test HW",
      "Utilizzo del PTLR",
      "Utilizzo della tabella delle pagine e del dei bit di validità",
      "Utilizzo di 2 registri che definiscano i confini dello spazio di memoria allocato al processo da usare per un test HW"
    ],
    "tipologia": "multiple"
  }
]